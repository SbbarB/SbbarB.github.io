<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monochrome Ferrofluid Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: white;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Mouse tracking
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let mouseWorldPos = new THREE.Vector3(0, 0, 0);
        
        // Monochrome color scheme - shades of gray
        const colors = [
            0x000000, // Black
            0x333333, // Dark gray
            0x666666, // Medium gray
            0x999999, // Light gray
            0xcccccc, // Very light gray
        ];
        
        // Store all ferrofluid objects
        const ferrofluids = [];
        
        // Create main large black ferrofluid in center
        function createMainFerrofluid() {
            const sphereRadius = 3.5; // Good visible size
            const subdivisions = 128;
            const geometry = new THREE.SphereGeometry(sphereRadius, subdivisions, subdivisions);
            
            const originalPositions = geometry.attributes.position.array.slice();
            const vertexCount = geometry.attributes.position.count;
            const velocities = new Float32Array(vertexCount);
            
            const material = new THREE.MeshPhongMaterial({
                color: 0x000000, // Pure black for main ferrofluid
                shininess: 150,
                specular: 0x666666,
                transparent: false,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, 0);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            ferrofluids.push({
                mesh: mesh,
                geometry: geometry,
                originalPositions: originalPositions,
                velocities: velocities,
                vertexCount: vertexCount,
                radius: sphereRadius,
                isMain: true
            });
        }
        
        // Create smaller monochrome ferrofluids scattered around
        function createSmallFerrofluids() {
            const numSmall = 12;
            const smallRadius = 1.8;
            const subdivisions = 96;
            
            for (let i = 0; i < numSmall; i++) {
                const geometry = new THREE.SphereGeometry(smallRadius, subdivisions, subdivisions);
                
                const originalPositions = geometry.attributes.position.array.slice();
                const vertexCount = geometry.attributes.position.count;
                const velocities = new Float32Array(vertexCount);
                
                const material = new THREE.MeshPhongMaterial({
                    color: colors[i % colors.length],
                    shininess: 150,
                    specular: 0x888888,
                    transparent: false,
                    side: THREE.DoubleSide
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // Scattered positioning in 3D space
                const angle = (i / numSmall) * Math.PI * 2 + Math.random() * 0.5;
                const distance = 8 + Math.random() * 10;
                const height = (Math.random() - 0.5) * 12;
                
                mesh.position.set(
                    Math.cos(angle) * distance + (Math.random() - 0.5) * 6,
                    height,
                    Math.sin(angle) * distance + (Math.random() - 0.5) * 6
                );
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                
                ferrofluids.push({
                    mesh: mesh,
                    geometry: geometry,
                    originalPositions: originalPositions,
                    velocities: velocities,
                    vertexCount: vertexCount,
                    radius: smallRadius,
                    isMain: false
                });
            }
        }
        
        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        const rimLight = new THREE.DirectionalLight(0x8888ff, 0.4);
        rimLight.position.set(-8, 5, -8);
        scene.add(rimLight);
        
        const frontLight = new THREE.DirectionalLight(0xffffff, 0.5);
        frontLight.position.set(0, 0, 15);
        scene.add(frontLight);
        
        // Create invisible plane for mouse ray casting
        const planeGeometry = new THREE.PlaneGeometry(40, 30);
        const planeMaterial = new THREE.MeshBasicMaterial({ 
            transparent: true, 
            opacity: 0,
            side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        scene.add(plane);
        
        // Position camera
        camera.position.set(0, 3, 25);
        camera.lookAt(0, 0, 0);
        
        // Mouse movement handler
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(plane);
            
            if (intersects.length > 0) {
                mouseWorldPos.copy(intersects[0].point);
            }
        }
        
        window.addEventListener('mousemove', onMouseMove);
        
        // Camera-directed ferrofluid physics - spikes grow toward viewer
        function updateFerrofluid(ferrofluid) {
            const positions = ferrofluid.geometry.attributes.position.array;
            const time = Date.now() * 0.001;
            
            // Get camera direction for spikes to grow toward viewer
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            const towardCamera = cameraDirection.clone().negate(); // Direction toward camera
            
            for (let i = 0; i < ferrofluid.vertexCount; i++) {
                const i3 = i * 3;
                
                const originalX = ferrofluid.originalPositions[i3];
                const originalY = ferrofluid.originalPositions[i3 + 1];
                const originalZ = ferrofluid.originalPositions[i3 + 2];
                
                const vertex = new THREE.Vector3(originalX, originalY, originalZ);
                const vertexNormal = vertex.clone().normalize();
                
                // Transform to world space
                const worldVertex = vertex.clone().add(ferrofluid.mesh.position);
                
                // Project both ferrofluid surface and mouse to screen space
                const vertexScreenPos = worldVertex.clone().project(camera);
                const mouseScreenPos = mouseWorldPos.clone().project(camera);
                
                // Calculate screen distance between cursor and this surface point
                const screenDistance = Math.sqrt(
                    Math.pow(mouseScreenPos.x - vertexScreenPos.x, 2) +
                    Math.pow(mouseScreenPos.y - vertexScreenPos.y, 2)
                );
                
                // Magnetic influence based on cursor proximity in screen space
                const maxScreenDistance = 0.4;
                const magneticInfluence = Math.max(0, (maxScreenDistance - screenDistance) / maxScreenDistance);
                
                // Check if this surface can grow toward the camera (faces generally toward viewer)
                const cameraAlignment = vertexNormal.dot(towardCamera);
                const canGrowTowardCamera = cameraAlignment > -0.3; // Allow surfaces that can extend toward camera
                
                // Base radius with subtle breathing
                const organicBreathing = Math.sin(time * 0.6 + vertex.length() * 1.0) * 0.02;
                let targetRadius = ferrofluid.radius + organicBreathing;
                
                // Create spikes growing toward the viewer when cursor is nearby
                if (canGrowTowardCamera && magneticInfluence > 0.02) {
                    const spikeScale = ferrofluid.isMain ? 1.0 : 0.8;
                    
                    // Primary spike toward camera based on cursor proximity
                    const primarySpikeStrength = Math.pow(magneticInfluence, 0.8) * Math.max(0.2, cameraAlignment);
                    const primarySpikeLength = primarySpikeStrength * 2.5 * spikeScale;
                    targetRadius += primarySpikeLength;
                    
                    // Secondary ring of spikes around primary direction
                    const angleFromCamera = Math.acos(Math.max(0, Math.min(1, Math.abs(cameraAlignment))));
                    
                    // Ring 1: Close to camera direction
                    if (angleFromCamera <= 0.6) {
                        const ring1Factor = Math.cos(angleFromCamera / 0.6 * Math.PI / 2);
                        const ring1Strength = Math.pow(ring1Factor, 1.2) * magneticInfluence;
                        const ring1Length = ring1Strength * 1.8 * spikeScale;
                        targetRadius += ring1Length;
                    }
                    
                    // Ring 2: Medium angle from camera
                    if (angleFromCamera <= 1.0 && angleFromCamera > 0.6) {
                        const normalizedAngle = (angleFromCamera - 0.6) / (1.0 - 0.6);
                        const ring2Factor = Math.cos(normalizedAngle * Math.PI / 2);
                        const ring2Strength = Math.pow(ring2Factor, 1.5) * magneticInfluence;
                        const ring2Length = ring2Strength * 1.2 * spikeScale;
                        targetRadius += ring2Length;
                    }
                    
                    // Ring 3: Outer spikes
                    if (angleFromCamera <= 1.4 && angleFromCamera > 1.0) {
                        const normalizedAngle = (angleFromCamera - 1.0) / (1.4 - 1.0);
                        const ring3Factor = Math.cos(normalizedAngle * Math.PI / 2);
                        const ring3Strength = Math.pow(ring3Factor, 2.0) * magneticInfluence;
                        const ring3Length = ring3Strength * 0.8 * spikeScale;
                        targetRadius += ring3Length;
                    }
                    
                    // Surface detail based on magnetic influence
                    const surfaceDetail = Math.sin(vertex.x * 4 + time * 1.2) * 
                                         Math.cos(vertex.y * 4 + time * 1.0) * 
                                         Math.sin(vertex.z * 4 + time * 0.8) * 0.02;
                    targetRadius += surfaceDetail * primarySpikeStrength;
                    
                    // Valley formation for better spike definition
                    if (primarySpikeStrength < 0.1 && magneticInfluence > 0.1) {
                        targetRadius -= 0.03;
                    }
                }
                
                // Surfaces facing away from camera stay stable
                if (!canGrowTowardCamera || magneticInfluence < 0.02) {
                    targetRadius = ferrofluid.radius - 0.01;
                }
                
                // Physics with glitch prevention
                const currentVertex = new THREE.Vector3(positions[i3], positions[i3 + 1], positions[i3 + 2]);
                const currentRadius = currentVertex.length();
                
                const radiusDiff = targetRadius - currentRadius;
                const springForce = 0.1;
                const damping = 0.92;
                
                ferrofluid.velocities[i] += radiusDiff * springForce;
                ferrofluid.velocities[i] *= damping;
                
                // Prevent glitches with velocity limiting
                const maxVelocity = 0.25;
                ferrofluid.velocities[i] = Math.max(-maxVelocity, Math.min(maxVelocity, ferrofluid.velocities[i]));
                
                const newRadius = Math.max(0.3, currentRadius + ferrofluid.velocities[i]);
                
                // Update vertex position with safety checks
                if (isFinite(newRadius) && newRadius > 0) {
                    positions[i3] = vertexNormal.x * newRadius;
                    positions[i3 + 1] = vertexNormal.y * newRadius;
                    positions[i3 + 2] = vertexNormal.z * newRadius;
                }
            }
            
            ferrofluid.geometry.attributes.position.needsUpdate = true;
            
            // Update normals for proper lighting
            if (Math.random() < 0.2) {
                ferrofluid.geometry.computeVertexNormals();
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update all ferrofluids
            ferrofluids.forEach(ferrofluid => {
                updateFerrofluid(ferrofluid);
            });
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Initialize and start
        createMainFerrofluid();
        createSmallFerrofluids();
        animate();
    </script>
</body>
</html>