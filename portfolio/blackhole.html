<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Hole</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 15px;
            right: 15px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div id="info">Sagittarius A*<br>Supermassive Black Hole</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // Event horizon - perfect black sphere
        const blackHole = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 64, 64),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        scene.add(blackHole);

        // Enhanced accretion disk with custom shader
        const diskVertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            varying float vRadius;
            
            void main() {
                vUv = uv;
                vPosition = position;
                vRadius = length(position.xy);
                
                vec3 pos = position;
                // Subtle gravitational warping effect
                float warp = 1.0 - 0.3 / (vRadius + 1.0);
                pos.z *= warp;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const diskFragmentShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            varying float vRadius;
            
            // Better noise function
            float hash(vec2 p) {
                return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));
            }
            
            float noise(vec2 x) {
                vec2 i = floor(x);
                vec2 f = fract(x);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            
            void main() {
                float r = vRadius;
                
                // Discard inner region (inside event horizon)
                if (r < 2.0) discard;
                if (r > 8.0) discard;
                
                // Temperature based on distance - hot center, cooler edges
                float temp = 1.0 / pow(r * 0.4, 0.8);
                
                // Add turbulence and spiral structure
                float angle = atan(vPosition.y, vPosition.x);
                float spiral = sin(angle * 2.0 - time * 0.8 + r * 0.5) * 0.2 + 1.0;
                
                // Turbulent motion
                vec2 turbCoord = vec2(angle * 6.0, r) + time * 0.3;
                float turbulence = noise(turbCoord) * 0.4 + 0.8;
                
                temp *= spiral * turbulence;
                
                // Convert temperature to realistic color
                vec3 color;
                if (temp > 1.5) {
                    color = vec3(1.0, 1.0, 1.0); // White hot
                } else if (temp > 1.0) {
                    color = mix(vec3(1.0, 0.9, 0.7), vec3(1.0, 1.0, 1.0), (temp - 1.0) * 2.0);
                } else if (temp > 0.6) {
                    color = mix(vec3(1.0, 0.6, 0.2), vec3(1.0, 0.9, 0.7), (temp - 0.6) * 2.5);
                } else if (temp > 0.3) {
                    color = mix(vec3(1.0, 0.3, 0.1), vec3(1.0, 0.6, 0.2), (temp - 0.3) * 3.33);
                } else {
                    color = mix(vec3(0.6, 0.1, 0.0), vec3(1.0, 0.3, 0.1), temp * 3.33);
                }
                
                // Brightness with smooth falloff
                float brightness = temp * (1.0 - smoothstep(2.0, 8.0, r));
                brightness = clamp(brightness, 0.0, 2.0);
                
                // Transparency for layering effect
                float alpha = brightness * 0.8;
                alpha *= smoothstep(2.0, 2.5, r); // Fade in from event horizon
                alpha *= smoothstep(8.0, 7.0, r); // Fade out at edges
                
                gl_FragColor = vec4(color * brightness, alpha);
            }
        `;

        // Create the main accretion disk
        const diskGeometry = new THREE.RingGeometry(2, 8, 128, 64);
        const diskMaterial = new THREE.ShaderMaterial({
            vertexShader: diskVertexShader,
            fragmentShader: diskFragmentShader,
            uniforms: {
                time: { value: 0 }
            },
            transparent: true,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
        accretionDisk.rotation.x = -Math.PI * 0.25; // Tilt for 3D effect
        scene.add(accretionDisk);

        // Secondary disk layer for depth
        const disk2 = new THREE.Mesh(diskGeometry, diskMaterial.clone());
        disk2.material.uniforms.time = { value: 0 };
        disk2.rotation.x = -Math.PI * 0.25;
        disk2.scale.setScalar(0.7);
        scene.add(disk2);

        // Swirling particles
        const particleCount = 8000;
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Distribute in disk with concentration near center
            const radius = 2.5 + Math.pow(Math.random(), 0.5) * 5.5;
            const angle = Math.random() * Math.PI * 2;
            const height = (Math.random() - 0.5) * 0.3 * Math.sqrt(radius / 4);
            
            positions[i3] = Math.cos(angle) * radius;
            positions[i3 + 1] = height;
            positions[i3 + 2] = Math.sin(angle) * radius;
            
            // Color based on temperature
            const temp = 1.0 / Math.pow(radius * 0.3, 0.8);
            if (temp > 1.2) {
                colors[i3] = 1.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 1.0;
            } else if (temp > 0.8) {
                colors[i3] = 1.0; colors[i3 + 1] = 0.9; colors[i3 + 2] = 0.7;
            } else if (temp > 0.5) {
                colors[i3] = 1.0; colors[i3 + 1] = 0.6; colors[i3 + 2] = 0.2;
            } else {
                colors[i3] = 1.0; colors[i3 + 1] = 0.3; colors[i3 + 2] = 0.1;
            }
            
            sizes[i] = Math.random() * 2 + 0.5;
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const particleMaterial = new THREE.PointsMaterial({
            vertexColors: true,
            size: 1,
            transparent: true,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particles.rotation.x = -Math.PI * 0.25;
        scene.add(particles);

        // Distant stars
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 1000; i++) {
            starPositions.push(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200
            );
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 0.3,
            sizeAttenuation: false
        }));
        scene.add(stars);

        // Camera setup
        camera.position.set(0, 6, 18);
        camera.lookAt(0, 0, 0);

        // Mouse interaction
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - window.innerWidth / 2) / window.innerWidth;
            mouseY = (event.clientY - window.innerHeight / 2) / window.innerHeight;
        });

        // Animation
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Update shaders
            accretionDisk.material.uniforms.time.value = time;
            disk2.material.uniforms.time.value = time * 0.8;

            // Rotate disks
            accretionDisk.rotation.z += 0.008;
            disk2.rotation.z += 0.012;

            // Animate particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];
                const radius = Math.sqrt(x * x + z * z);
                const angle = Math.atan2(z, x);
                const speed = 1 / Math.sqrt(radius) * 0.01;
                
                const newAngle = angle + speed;
                positions[i] = Math.cos(newAngle) * radius;
                positions[i + 2] = Math.sin(newAngle) * radius;

                // Reset particles that fall in
                if (radius < 2.2) {
                    const newRadius = 6 + Math.random() * 2;
                    const resetAngle = Math.random() * Math.PI * 2;
                    positions[i] = Math.cos(resetAngle) * newRadius;
                    positions[i + 2] = Math.sin(resetAngle) * newRadius;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Smooth camera movement
            targetX += (mouseX - targetX) * 0.02;
            targetY += (mouseY - targetY) * 0.02;
            
            camera.position.x = Math.sin(targetX * Math.PI) * 18;
            camera.position.z = Math.cos(targetX * Math.PI) * 18;
            camera.position.y = 6 + targetY * 8;
            camera.lookAt(0, 0, 0);

            // Gentle scene rotation
            scene.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>