<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ferrofluid Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: white;
            overflow: hidden;
        }
        canvas {
            background: white;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Mouse position
        let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
        
        // Particle class for ferrofluid
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.size = Math.random() * 3 + 1;
                this.originalX = x;
                this.originalY = y;
            }
            
            update() {
                // Calculate distance to mouse (magnet)
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                if (distance < 120) {
                    // Determine which "spike sector" this particle belongs to (creates distinct spikes)
                    const numSpikes = 8; // Number of spike directions
                    const sectorAngle = (Math.PI * 2) / numSpikes;
                    const sector = Math.round(angle / sectorAngle);
                    const targetAngle = sector * sectorAngle;
                    
                    // Calculate target position for this spike
                    const spikeLength = Math.max(25, 60 - distance * 0.3);
                    const targetX = mouse.x + Math.cos(targetAngle) * spikeLength;
                    const targetY = mouse.y + Math.sin(targetAngle) * spikeLength;
                    
                    // Smooth movement toward spike position
                    const moveForce = 0.02;
                    this.vx += (targetX - this.x) * moveForce;
                    this.vy += (targetY - this.y) * moveForce;
                    
                    // Additional attraction toward the magnet (but not too strong)
                    const magnetAttraction = Math.min(80 / (distance + 20), 2);
                    this.vx += Math.cos(angle) * magnetAttraction * 0.003;
                    this.vy += Math.sin(angle) * magnetAttraction * 0.003;
                    
                    // Align with other particles in the same spike
                    this.formSpike(targetAngle);
                    
                } else if (distance < 200) {
                    // Gentle attraction from medium distance
                    const attraction = Math.min(40 / (distance + 10), 1.5);
                    this.vx += Math.cos(angle) * attraction * 0.002;
                    this.vy += Math.sin(angle) * attraction * 0.002;
                } else {
                    // Return to original position when far from magnet
                    const restoreForce = 0.001;
                    this.vx += (this.originalX - this.x) * restoreForce;
                    this.vy += (this.originalY - this.y) * restoreForce;
                }
                
                // Strong damping for smooth movement
                this.vx *= 0.85;
                this.vy *= 0.85;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Keep particles in bounds
                if (this.x < 0) this.x = 0;
                if (this.x > canvas.width) this.x = canvas.width;
                if (this.y < 0) this.y = 0;
                if (this.y > canvas.height) this.y = canvas.height;
            }
            
            formSpike(targetAngle) {
                // Find nearby particles that should be part of the same spike
                const spikeRadius = 35;
                const angleThreshold = 0.4;
                
                particles.forEach(other => {
                    if (other === this) return;
                    
                    const otherDx = mouse.x - other.x;
                    const otherDy = mouse.y - other.y;
                    const otherDistance = Math.sqrt(otherDx * otherDx + otherDy * otherDy);
                    const otherAngle = Math.atan2(otherDy, otherDx);
                    
                    // Check if other particle is in same spike direction
                    const angleDiff = Math.abs(targetAngle - otherAngle);
                    const normalizedAngleDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                    
                    if (normalizedAngleDiff < angleThreshold && otherDistance < 120) {
                        const particleDist = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                        
                        if (particleDist < spikeRadius) {
                            // Gently align positions to form coherent spike
                            const alignForce = 0.008;
                            const avgX = (this.x + other.x) / 2;
                            const avgY = (this.y + other.y) / 2;
                            
                            this.vx += (avgX - this.x) * alignForce;
                            this.vy += (avgY - this.y) * alignForce;
                        }
                    }
                });
            }
            
            draw() {
                // Calculate distance to cursor for dynamic sizing
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Dynamic particle size based on proximity to magnet
                let dynamicSize = this.size;
                if (distance < 120) {
                    dynamicSize = this.size + (120 - distance) * 0.02;
                }
                
                // Create gradient effect for more liquid appearance
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, dynamicSize * 2);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
                gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.6)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, dynamicSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Create particle grid for ferrofluid
        const particles = [];
        const spacing = 15;
        for (let x = spacing; x < canvas.width; x += spacing) {
            for (let y = spacing; y < canvas.height; y += spacing) {
                // Add some randomness to initial positions
                const offsetX = (Math.random() - 0.5) * 10;
                const offsetY = (Math.random() - 0.5) * 10;
                particles.push(new Particle(x + offsetX, y + offsetY));
            }
        }
        
        // Mouse tracking
        document.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        // Animation loop
        function animate() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw particles
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            // Draw connections between nearby particles for fluid effect
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 30) {
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>