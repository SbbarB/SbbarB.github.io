<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record Player Exploded Anatomy</title>
    <style>
        body {
            margin: 0;
            background: #ffffff;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        #projectButton {
            background: #333;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        }

        #projectButton:hover {
            background: #555;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.25);
        }

        #projectButton:active {
            transform: translateY(0);
        }

        #projectButton.active {
            background: #f5f7f8;
            color: #333;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 18px;
            color: #666;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">Loading model...</div>
    <div id="controls" style="display: none;">
        <button id="projectButton">The Collection</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.5, 1000);
        camera.position.set(0, 90, 380,);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.insertBefore(renderer.domElement, document.body.firstChild);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = false;
        controls.target.set(0, 40, 0);
        controls.minDistance = 10; // Allow very close zoom
        controls.maxDistance = 2000; // Allow very far zoom

        // Lighting - Brighter for better visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(300, 400, 200);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.left = -300;
        mainLight.shadow.camera.right = 300;
        mainLight.shadow.camera.top = 300;
        mainLight.shadow.camera.bottom = -300;
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.8);
        fillLight.position.set(-200, 200, -200);
        scene.add(fillLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 0.6);
        rimLight.position.set(0, 150, -300);
        scene.add(rimLight);

        // Ground removed - no shadow plane needed

        // Component tracking with logical grouping
        const components = [];
        let isExploded = false;
        let animationProgress = 0;

        // Component categorization by name patterns and positions
        const componentCategories = {
            // Layer 0: Case walls and structure (will be made transparent)
            'Cube_TapeRecorder_0': { order: 0, name: 'Case Walls' },
            'Cube006_TapeRecorder_0': { order: 0, name: 'Case Back Wall' },

            // Layer -3: Floor (bottom wooden panel that falls out) - will be auto-detected
            // 'Cube002_TapeRecorder_0': { order: -3, name: 'Wooden Floor Panel' },

            // Layer 1: Internal electronics base (55%)
            'Cylinder007_TapeRecorder_0': { order: 1, name: 'Speaker Grille 1' },
            'Cylinder008_TapeRecorder_0': { order: 1, name: 'Right Speaker' },
            'Cylinder004_TapeRecorder_0': { order: 1, name: 'Left Speaker' },
            'Cube007_TapeRecorder_0': { order: 1, name: 'Hinge Mechanism' },
            'Cylinder003_TapeRecorder_0': { order: 1, name: 'Tonearm Pivot' },

            // Layer 2: Turntable mechanism (58-64%)
            'Cylinder001_TapeRecorder_0': { order: 2, name: 'Platter Base' },
            'Cylinder_TapeRecorder_0': { order: 3, name: 'Turntable Platter' },
            'Cube003_TapeRecorder_0': { order: 2, name: 'Control Mount' },

            // Layer 3: Upper mechanisms (66-67%)
            'Cylinder005_TapeRecorder_0': { order: 4, name: 'Spindle' },
            'Cylinder010_TapeRecorder_0': { order: 3, name: 'Speaker Grille 2' },

            // Layer 4: Controls and tonearm (75-82%)
            'Cube004_TapeRecorder_0': { order: 5, name: 'Control Panel' },
            'Cube001_TapeRecorder_0': { order: 5, name: 'Control Buttons' },
            'Cylinder002_TapeRecorder_0': { order: 6, name: 'Tonearm' },

            // Layer 6: Lid (91%)
            'Cube005_Glass_0': { order: 7, name: 'Glass Lid' }
        };

        // Helper function to create detailed PCB with realistic components
        function createDetailedPCB(width, depth, componentsConfig) {
            const pcbGroup = new THREE.Group();

            // Realistic purple PCB base with fiberglass texture
            const pcbBase = new THREE.Mesh(
                new THREE.BoxGeometry(width, 2, depth),
                new THREE.MeshStandardMaterial({
                    color: 0x6b2d8a, // Darker, more realistic PCB purple
                    roughness: 0.8,
                    metalness: 0.1,
                    envMapIntensity: 0.3
                })
            );
            pcbBase.castShadow = true;
            pcbBase.receiveShadow = true;
            pcbGroup.add(pcbBase);

            // Helper function to create a trace between two points
            function createTrace(x1, z1, x2, z2) {
                const length = Math.sqrt((x2-x1)**2 + (z2-z1)**2);
                const angle = Math.atan2(z2-z1, x2-x1);
                const trace = new THREE.Mesh(
                    new THREE.BoxGeometry(length, 0.15, 0.4),
                    new THREE.MeshStandardMaterial({
                        color: 0xcd7f32, // Realistic copper color
                        roughness: 0.2,
                        metalness: 0.95,
                        emissive: 0x442200,
                        emissiveIntensity: 0.1
                    })
                );
                trace.position.set((x1+x2)/2, 1.1, (z1+z2)/2);
                trace.rotation.y = angle;
                pcbGroup.add(trace);
            }

            // Helper function to add solder pad at component location
            function addPad(x, z) {
                const pad = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.2, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xe8e8e8, // Bright solder tin color
                        roughness: 0.15,
                        metalness: 0.98,
                        emissive: 0x444444,
                        emissiveIntensity: 0.05
                    })
                );
                pad.position.set(x, 1.1, z);
                pcbGroup.add(pad);
            }

            // Add components on top of PCB
            componentsConfig.forEach(config => {
                let component;

                if (config.type === 'cylinder') {
                    // Cylindrical components (capacitors, potentiometers)
                    component = new THREE.Mesh(
                        new THREE.CylinderGeometry(config.r || config.w/2, config.r || config.w/2, config.h, 16),
                        new THREE.MeshStandardMaterial({
                            color: config.color,
                            roughness: config.roughness || 0.5,
                            metalness: config.metalness || 0.2,
                            envMapIntensity: 0.4
                        })
                    );
                    component.position.set(config.x, 1 + config.h / 2, config.z);
                } else if (config.type === 'heatsink') {
                    // Heatsink with fins - highly metallic aluminum
                    const heatsinkGroup = new THREE.Group();
                    const base = new THREE.Mesh(
                        new THREE.BoxGeometry(config.w, config.h * 0.3, config.d),
                        new THREE.MeshStandardMaterial({
                            color: config.color,
                            roughness: 0.15,
                            metalness: 0.95,
                            envMapIntensity: 0.8
                        })
                    );
                    heatsinkGroup.add(base);

                    // Add fins
                    for (let i = 0; i < 8; i++) {
                        const fin = new THREE.Mesh(
                            new THREE.BoxGeometry(config.w, config.h * 0.7, 0.3),
                            new THREE.MeshStandardMaterial({
                                color: config.color,
                                roughness: 0.15,
                                metalness: 0.95,
                                envMapIntensity: 0.8
                            })
                        );
                        fin.position.set(0, config.h * 0.35, (i - 3.5) * (config.d / 8));
                        heatsinkGroup.add(fin);
                    }

                    component = heatsinkGroup;
                    component.position.set(config.x, 1, config.z);
                } else if (config.type === 'ic') {
                    // IC chip with pins - matte plastic body
                    const icGroup = new THREE.Group();
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(config.w, config.h, config.d),
                        new THREE.MeshStandardMaterial({
                            color: config.color,
                            roughness: 0.85,
                            metalness: 0.05,
                            envMapIntensity: 0.1
                        })
                    );
                    icGroup.add(body);

                    // Add pins - shiny metal
                    for (let i = 0; i < 8; i++) {
                        const pin = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.5, 0.2),
                            new THREE.MeshStandardMaterial({
                                color: 0xd0d0d0,
                                roughness: 0.1,
                                metalness: 0.98,
                                envMapIntensity: 0.7
                            })
                        );
                        pin.position.set((i - 3.5) * (config.w / 8), -config.h/2 - 0.25, config.d/2 + 0.1);
                        icGroup.add(pin);
                    }

                    component = icGroup;
                    component.position.set(config.x, 1 + config.h / 2, config.z);
                } else if (config.type === 'resistor') {
                    // Resistor (small cylinder) - ceramic/carbon film
                    component = new THREE.Mesh(
                        new THREE.CylinderGeometry(config.r || 0.4, config.r || 0.4, config.h, 8),
                        new THREE.MeshStandardMaterial({
                            color: config.color,
                            roughness: 0.75,
                            metalness: 0.05,
                            envMapIntensity: 0.2
                        })
                    );
                    component.position.set(config.x, 1 + config.h / 2, config.z);
                    component.rotation.z = Math.PI / 2;
                } else if (config.type === 'led') {
                    // LED (rounded top) - translucent with glow
                    const ledGeo = new THREE.CylinderGeometry(0, config.r || 0.5, config.h, 8);
                    component = new THREE.Mesh(
                        ledGeo,
                        new THREE.MeshStandardMaterial({
                            color: config.color,
                            roughness: 0.2,
                            metalness: 0.0,
                            transparent: true,
                            opacity: 0.8,
                            emissive: config.color,
                            emissiveIntensity: 0.7
                        })
                    );
                    component.position.set(config.x, 1 + config.h / 2, config.z);
                } else {
                    // Default box component (connectors, etc.)
                    component = new THREE.Mesh(
                        new THREE.BoxGeometry(config.w, config.h, config.d),
                        new THREE.MeshStandardMaterial({
                            color: config.color,
                            roughness: config.roughness || 0.6,
                            metalness: config.metalness || 0.3,
                            envMapIntensity: 0.3
                        })
                    );
                    component.position.set(config.x, 1 + config.h / 2, config.z);
                }

                component.castShadow = true;
                pcbGroup.add(component);

                // Add solder pads at component locations
                if (config.type === 'ic') {
                    // IC has pins on both sides
                    for (let i = 0; i < 4; i++) {
                        addPad(config.x + (i - 1.5) * 2, config.z + config.d/2 + 1);
                        addPad(config.x + (i - 1.5) * 2, config.z - config.d/2 - 1);
                    }
                } else if (config.type === 'resistor' || config.type === 'led') {
                    // Two-terminal components
                    addPad(config.x - config.h/2 - 1, config.z);
                    addPad(config.x + config.h/2 + 1, config.z);
                } else if (config.type === 'cylinder') {
                    // Capacitors have two pads
                    addPad(config.x - 1, config.z);
                    addPad(config.x + 1, config.z);
                } else {
                    // Default: single pad at component location
                    addPad(config.x, config.z);
                }
            });

            // Create realistic circuit traces connecting components
            // Power rails (horizontal lines running along edges)
            createTrace(-width/2 + 5, -depth/2 + 3, width/2 - 5, -depth/2 + 3); // Ground rail
            createTrace(-width/2 + 5, depth/2 - 3, width/2 - 5, depth/2 - 3); // VCC rail

            // Build a map of components by type for intelligent routing
            const ics = componentsConfig.filter(c => c.type === 'ic');
            const capacitors = componentsConfig.filter(c => c.type === 'cylinder');
            const resistors = componentsConfig.filter(c => c.type === 'resistor');
            const heatsinks = componentsConfig.filter(c => c.type === 'heatsink');
            const connectors = componentsConfig.filter(c => c.type === 'box' && (c.color === 0xe8e8e8 || c.color === 0xffffff || c.color === 0x0033aa));

            // Connect power supply: connectors → capacitors → ICs
            connectors.forEach((connector, i) => {
                // Connect connector to nearest capacitor
                if (i < capacitors.length) {
                    const cap = capacitors[i];
                    createTrace(connector.x, connector.z, cap.x, cap.z);

                    // Connect capacitor to ground rail
                    createTrace(cap.x, cap.z, cap.x, -depth/2 + 3);
                }
            });

            // Connect ICs to nearby capacitors (decoupling)
            ics.forEach(ic => {
                // Find closest capacitor for decoupling
                let closest = null;
                let minDist = Infinity;
                capacitors.forEach(cap => {
                    const dist = Math.sqrt((ic.x - cap.x)**2 + (ic.z - cap.z)**2);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = cap;
                    }
                });

                if (closest && minDist < 35) {
                    // Route via intermediate point for L-shaped trace
                    const midX = ic.x;
                    const midZ = closest.z;
                    createTrace(ic.x, ic.z, midX, midZ);
                    createTrace(midX, midZ, closest.x, closest.z);
                }

                // Connect IC to power rail
                createTrace(ic.x, ic.z, ic.x, depth/2 - 3);

                // Connect IC to ground via nearby resistor if available
                const nearbyResistor = resistors.find(r =>
                    Math.abs(r.x - ic.x) < 15 && Math.abs(r.z - ic.z) < 15
                );
                if (nearbyResistor) {
                    createTrace(ic.x, ic.z - ic.d/2, nearbyResistor.x, nearbyResistor.z);
                    createTrace(nearbyResistor.x, nearbyResistor.z, nearbyResistor.x, -depth/2 + 3);
                }
            });

            // Connect heatsinks to power output
            heatsinks.forEach((hs, i) => {
                // Connect to power rail
                createTrace(hs.x, hs.z, hs.x + 5, hs.z + 5);
                createTrace(hs.x + 5, hs.z + 5, hs.x + 5, depth/2 - 3);

                // Connect heatsinks to each other (series connection)
                if (i < heatsinks.length - 1) {
                    const next = heatsinks[i + 1];
                    createTrace(hs.x, hs.z, next.x, next.z);
                }
            });

            // Connect signal path: input connectors → ICs → output connectors
            if (ics.length >= 2 && connectors.length >= 2) {
                // Input connector → IC1
                createTrace(connectors[0].x, connectors[0].z, ics[0].x, ics[0].z);

                // IC1 → IC2 (signal path)
                if (ics.length > 1) {
                    const midX = (ics[0].x + ics[1].x) / 2;
                    createTrace(ics[0].x, ics[0].z, midX, ics[0].z);
                    createTrace(midX, ics[0].z, midX, ics[1].z);
                    createTrace(midX, ics[1].z, ics[1].x, ics[1].z);
                }

                // IC → output connector
                const lastIC = ics[ics.length - 1];
                const outputConnector = connectors[connectors.length - 1];
                createTrace(lastIC.x, lastIC.z, outputConnector.x, outputConnector.z);
            }

            // Connect remaining resistors to nearby components
            resistors.forEach(res => {
                // Connect resistor to nearest ground
                createTrace(res.x, res.z, res.x, -depth/2 + 3);
            });

            return pcbGroup;
        }

        // Helper function to create curved wire with realistic physics
        function createWire(start, end, color, radius = 0.8) {
            // Minimum Y constraint - wires must stay above PCB surface
            const minWireY = 7; // pcbSurfaceY value

            // Calculate control points for realistic wire sagging
            const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);

            // Add gravity sag - wires droop in the middle
            const horizontalDist = Math.sqrt(
                Math.pow(end.x - start.x, 2) + Math.pow(end.z - start.z, 2)
            );
            const sagAmount = Math.min(horizontalDist * 0.15, 15); // Sag proportional to length
            // CONSTRAIN: Don't let sag go below PCB surface
            midPoint.y = Math.max(minWireY, midPoint.y - sagAmount);

            // Add slight horizontal offset for natural routing
            const perpendicular = new THREE.Vector3(
                -(end.z - start.z),
                0,
                (end.x - start.x)
            ).normalize();

            // Offset slightly to avoid clipping through model
            const offset1 = perpendicular.clone().multiplyScalar(8);
            const offset2 = perpendicular.clone().multiplyScalar(-8);

            // Create intermediate control points with Y constraint
            const controlPoint1 = start.clone().add(offset1).lerp(midPoint, 0.3);
            controlPoint1.y = Math.max(minWireY, controlPoint1.y);

            const controlPoint2 = end.clone().add(offset2).lerp(midPoint, 0.3);
            controlPoint2.y = Math.max(minWireY, controlPoint2.y);

            // Create curve with multiple control points
            const curve = new THREE.CatmullRomCurve3([
                start.clone(),
                controlPoint1,
                midPoint.clone(),
                controlPoint2,
                end.clone()
            ]);

            // Create tube geometry along curve
            const tubeGeometry = new THREE.TubeGeometry(curve, 32, radius, 8, false);
            const wireMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.6,
                metalness: 0.2
            });

            const wire = new THREE.Mesh(tubeGeometry, wireMaterial);
            wire.castShadow = true;
            wire.receiveShadow = true;

            return wire;
        }

        // Load GLB model
        const loader = new GLTFLoader();
        loader.load('record_player_for_vinyls.glb', (gltf) => {
            const model = gltf.scene;

            // Calculate bounding box for centering
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Center the model
            model.position.sub(center);
            model.position.y += size.y / 2;

            // First pass: find the floor (lowest wooden piece with TapeRecorder material)
            let floorMesh = null;
            let lowestY = Infinity;

            model.traverse((child) => {
                if (child.isMesh && child.name.includes('TapeRecorder')) {
                    const worldPos = new THREE.Vector3();
                    child.getWorldPosition(worldPos);

                    // Find lowest positioned mesh that's likely the floor
                    if (worldPos.y < lowestY && !child.name.includes('Glass')) {
                        lowestY = worldPos.y;
                        floorMesh = child;
                    }
                }
            });

            // Add floor to categories if found
            if (floorMesh) {
                componentCategories[floorMesh.name] = { order: -3, name: 'Wooden Floor Panel' };
                console.log('Floor identified:', floorMesh.name, 'at Y:', lowestY);
            }

            // Traverse and categorize components
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;

                    // Make acrylic/glass materials transparent (lid - brighter)
                    if (child.material && child.material.name === 'Glass') {
                        child.material = child.material.clone();
                        child.material.color.setHex(0xffffff);
                        child.material.opacity = 0.15; // Much more transparent
                        child.material.transparent = true;
                        child.material.roughness = 0.05;
                        child.material.metalness = 0.0;
                    }

                    // Make case body and floor transparent acrylic (not wood texture)
                    if (child.name === 'Cube_TapeRecorder_0' || child.name === 'Cube006_TapeRecorder_0' ||
                        (floorMesh && child.name === floorMesh.name)) {
                        child.material = child.material.clone();
                        child.material.color.setHex(0xffffff);
                        child.material.opacity = 0.2; // Slightly more transparent
                        child.material.transparent = true;
                        child.material.roughness = 0.05;
                        child.material.metalness = 0.0;
                        child.material.side = THREE.DoubleSide; // Render both sides to fix glitching
                    }

                    // Get category info
                    const category = componentCategories[child.name] || { order: 0, name: child.name };

                    // Store original world position and rotation
                    const worldPos = new THREE.Vector3();
                    const worldQuat = new THREE.Quaternion();
                    const worldScale = new THREE.Vector3();

                    child.getWorldPosition(worldPos);
                    child.getWorldQuaternion(worldQuat);
                    child.getWorldScale(worldScale);

                    // Store component
                    components.push({
                        mesh: child,
                        parent: child.parent,
                        order: category.order,
                        name: category.name,
                        baseWorldPos: worldPos.clone(),
                        baseWorldQuat: worldQuat.clone(),
                        baseWorldScale: worldScale.clone(),
                        baseLocalPos: child.position.clone(),
                        baseLocalQuat: child.quaternion.clone(),
                        baseLocalScale: child.scale.clone()
                    });

                    console.log(`${category.name} (${child.name}): Layer ${category.order}`);
                }
            });

            scene.add(model);

            // Create Unitra Control Block PCB (larger, more components)
            const unitraPCB = createDetailedPCB(90, 70, [
                // Large heatsinks with fins (transistors)
                { type: 'heatsink', x: -25, z: 20, w: 12, h: 10, d: 10, color: 0x1a1a1a },
                { type: 'heatsink', x: -10, z: 20, w: 12, h: 10, d: 10, color: 0x1a1a1a },
                { type: 'heatsink', x: 5, z: 20, w: 10, h: 8, d: 8, color: 0x333333 },

                // Large electrolytic capacitors (black cylinders)
                { type: 'cylinder', x: 0, z: -15, r: 4, h: 14, color: 0x1a1a1a },
                { type: 'cylinder', x: 12, z: -15, r: 4, h: 14, color: 0x1a1a1a },
                { type: 'cylinder', x: -12, z: -15, r: 3.5, h: 12, color: 0x333333 },
                { type: 'cylinder', x: -30, z: 0, r: 4, h: 12, color: 0x1a1a1a },
                { type: 'cylinder', x: 25, z: -10, r: 3, h: 10, color: 0x333333 },

                // Blue potentiometer
                { type: 'cylinder', x: 20, z: 5, r: 3, h: 5, color: 0x0066cc },

                // White/Grey capacitors
                { type: 'cylinder', x: -18, z: 5, r: 2.5, h: 8, color: 0xcccccc },
                { type: 'cylinder', x: 32, z: 15, r: 2, h: 7, color: 0xe0e0e0 },

                // AC Connector (white/silver)
                { type: 'box', x: -35, z: -25, w: 10, h: 4, d: 15, color: 0xe8e8e8, metalness: 0.9 },

                // Black connector blocks
                { type: 'box', x: 35, z: 0, w: 5, h: 4, d: 20, color: 0x1a1a1a },
                { type: 'box', x: 35, z: -22, w: 5, h: 4, d: 12, color: 0x1a1a1a },

                // IC chips with pins
                { type: 'ic', x: -5, z: 8, w: 8, h: 2.5, d: 6, color: 0x1a1a1a },
                { type: 'ic', x: 8, z: -3, w: 6, h: 2, d: 5, color: 0x1a1a1a },
                { type: 'ic', x: 15, z: 12, w: 6, h: 2, d: 6, color: 0x2a2a2a },

                // Small resistors scattered
                { type: 'resistor', x: -8, z: -5, h: 4, r: 0.5, color: 0xcc6600 },
                { type: 'resistor', x: 3, z: 0, h: 4, r: 0.5, color: 0xcc6600 },
                { type: 'resistor', x: -15, z: -10, h: 4, r: 0.5, color: 0xd4af37 },
                { type: 'resistor', x: 18, z: -8, h: 4, r: 0.5, color: 0xcc6600 },

                // Small SMD components
                { type: 'box', x: -22, z: -8, w: 2, h: 1, d: 1.5, color: 0x1a1a1a },
                { type: 'box', x: -18, z: -12, w: 2, h: 1, d: 1.5, color: 0x1a1a1a },
                { type: 'box', x: 5, z: -8, w: 2, h: 1, d: 1.5, color: 0x2a2a2a }
            ]);
            const unitraWorldPos = new THREE.Vector3(-50, 5, 0); // Inside the case, far left side
            unitraPCB.position.copy(unitraWorldPos);
            scene.add(unitraPCB);
            components.push({
                mesh: unitraPCB,
                parent: null,
                order: -2,
                name: 'Unitra Control Block PCB',
                baseWorldPos: unitraWorldPos.clone(),
                baseWorldQuat: new THREE.Quaternion(),
                baseWorldScale: new THREE.Vector3(1, 1, 1),
                baseLocalPos: unitraWorldPos.clone(),
                baseLocalQuat: new THREE.Quaternion(),
                baseLocalScale: new THREE.Vector3(1, 1, 1)
            });

            // Create Pentode Phono Stage PCB (smaller, cleaner design)
            const phonoPCB = createDetailedPCB(75, 55, [
                // Blue screw terminal blocks (3 positions)
                { type: 'box', x: -28, z: 20, w: 8, h: 6, d: 7, color: 0x0033aa },
                { type: 'box', x: 28, z: 20, w: 8, h: 6, d: 7, color: 0x0033aa },
                { type: 'box', x: 28, z: -20, w: 8, h: 6, d: 7, color: 0x0033aa },

                // White terminal connectors
                { type: 'box', x: -28, z: 0, w: 10, h: 4, d: 12, color: 0xffffff },
                { type: 'box', x: -28, z: -20, w: 10, h: 4, d: 8, color: 0xf0f0f0 },

                // IC chips (dual op-amp)
                { type: 'ic', x: 0, z: 2, w: 8, h: 2.5, d: 7, color: 0x1a1a1a },
                { type: 'ic', x: -8, z: -10, w: 6, h: 2, d: 6, color: 0x2a2a2a },

                // Electrolytic capacitors (black cylinders)
                { type: 'cylinder', x: -12, z: 5, r: 2, h: 9, color: 0x1a1a1a },
                { type: 'cylinder', x: 10, z: 5, r: 2, h: 9, color: 0x1a1a1a },
                { type: 'cylinder', x: -5, z: -18, r: 1.5, h: 7, color: 0x333333 },
                { type: 'cylinder', x: 5, z: -18, r: 1.5, h: 7, color: 0x333333 },

                // Film capacitors (orange/yellow boxes)
                { type: 'box', x: 15, z: 0, w: 4, h: 3, d: 2, color: 0xff9900 },
                { type: 'box', x: 18, z: 8, w: 4, h: 3, d: 2, color: 0xffaa00 },

                // Resistors (color-coded)
                { type: 'resistor', x: -3, z: 12, h: 4, r: 0.5, color: 0xcc6600 },
                { type: 'resistor', x: 3, z: 12, h: 4, r: 0.5, color: 0xcc6600 },
                { type: 'resistor', x: 0, z: -8, h: 3.5, r: 0.4, color: 0xd4af37 },
                { type: 'resistor', x: 12, z: -12, h: 3.5, r: 0.4, color: 0xcc6600 },
                { type: 'resistor', x: -12, z: -15, h: 3, r: 0.4, color: 0x8b4513 },

                // Green LED indicator
                { type: 'led', x: 20, z: -8, r: 1, h: 4, color: 0x00ff00 },

                // Small SMD components
                { type: 'box', x: -15, z: 8, w: 1.5, h: 0.8, d: 1, color: 0x1a1a1a },
                { type: 'box', x: 8, z: -5, w: 1.5, h: 0.8, d: 1, color: 0x2a2a2a },
                { type: 'box', x: 15, z: 10, w: 1.5, h: 0.8, d: 1, color: 0x1a1a1a }
            ]);
            const phonoWorldPos = new THREE.Vector3(50, 5, 0); // Inside the case, far right side
            phonoPCB.position.copy(phonoWorldPos);
            scene.add(phonoPCB);
            components.push({
                mesh: phonoPCB,
                parent: null,
                order: -1,
                name: 'Pentode Phono Stage PCB',
                baseWorldPos: phonoWorldPos.clone(),
                baseWorldQuat: new THREE.Quaternion(),
                baseWorldScale: new THREE.Vector3(1, 1, 1),
                baseLocalPos: phonoWorldPos.clone(),
                baseLocalQuat: new THREE.Quaternion(),
                baseLocalScale: new THREE.Vector3(1, 1, 1)
            });

            // Find actual component positions for wire routing
            const leftSpeaker = components.find(c => c.name === 'Left Speaker');
            const rightSpeaker = components.find(c => c.name === 'Right Speaker');
            const speakerGrille1 = components.find(c => c.name === 'Speaker Grille 1');
            const speakerGrille2 = components.find(c => c.name === 'Speaker Grille 2');
            const tonearm = components.find(c => c.name === 'Tonearm');
            const tonearmPivot = components.find(c => c.name === 'Tonearm Pivot');
            const platterBase = components.find(c => c.name === 'Platter Base');
            const turntablePlatter = components.find(c => c.name === 'Turntable Platter');
            const controlPanel = components.find(c => c.name === 'Control Panel');
            const controlButtons = components.find(c => c.name === 'Control Buttons');
            const spindle = components.find(c => c.name === 'Case Back Wall');

            // Create wires connecting PCBs to actual turntable components (3D circuit board)
            const wireConfigs = [];

            // Define wire Y constraints based on actual geometry
            // PCB boards are at Y=5, with components up to Y~16
            // Floor/plate is around Y=0-2
            // Wires must: start from PCB top (Y=7), route ABOVE tallest PCB components, touch component bottoms
            const pcbSurfaceY = 7; // Just above PCB base at Y=5+2
            const wireRouteY = 18; // Above all PCB components (tallest is ~16)

            // Speakers: Amplifier output (Unitra PCB) → Speaker terminals (2 wires each)
            if (leftSpeaker && rightSpeaker) {
                const leftSpeakerBox = new THREE.Box3().setFromObject(leftSpeaker.mesh);
                const rightSpeakerBox = new THREE.Box3().setFromObject(rightSpeaker.mesh);

                wireConfigs.push(
                    // Left speaker - wire 1 (red positive)
                    {
                        start: new THREE.Vector3(-85, pcbSurfaceY, 15),
                        end: new THREE.Vector3(
                            leftSpeaker.baseWorldPos.x - 3,
                            Math.max(wireRouteY, leftSpeakerBox.min.y - 0.5),
                            leftSpeaker.baseWorldPos.z
                        ),
                        color: 0xff0000,
                        order: -0.7
                    },
                    // Left speaker - wire 2 (black negative)
                    {
                        start: new THREE.Vector3(-80, pcbSurfaceY, 20),
                        end: new THREE.Vector3(
                            leftSpeaker.baseWorldPos.x + 3,
                            Math.max(wireRouteY, leftSpeakerBox.min.y - 0.5),
                            leftSpeaker.baseWorldPos.z
                        ),
                        color: 0x1a1a1a,
                        order: -0.7
                    },
                    // Right speaker - wire 1 (red positive)
                    {
                        start: new THREE.Vector3(-85, pcbSurfaceY, -15),
                        end: new THREE.Vector3(
                            rightSpeaker.baseWorldPos.x - 3,
                            Math.max(wireRouteY, rightSpeakerBox.min.y - 0.5),
                            rightSpeaker.baseWorldPos.z
                        ),
                        color: 0xff0000,
                        order: -0.7
                    },
                    // Right speaker - wire 2 (black negative)
                    {
                        start: new THREE.Vector3(-80, pcbSurfaceY, -20),
                        end: new THREE.Vector3(
                            rightSpeaker.baseWorldPos.x + 3,
                            Math.max(wireRouteY, rightSpeakerBox.min.y - 0.5),
                            rightSpeaker.baseWorldPos.z
                        ),
                        color: 0x1a1a1a,
                        order: -0.7
                    }
                );
            }


            // Platter motor: Power from Unitra PCB → Motor in platter base (2 wires)
            if (platterBase) {
                const platterBaseBox = new THREE.Box3().setFromObject(platterBase.mesh);

                wireConfigs.push(
                    // Motor wire 1 (blue AC power)
                    {
                        start: new THREE.Vector3(-70, pcbSurfaceY, -30),
                        end: new THREE.Vector3(
                            platterBase.baseWorldPos.x - 8,
                            Math.max(wireRouteY, platterBaseBox.min.y - 0.5),
                            platterBase.baseWorldPos.z
                        ),
                        color: 0x0066cc,
                        order: -0.4
                    },
                    // Motor wire 2 (brown AC power)
                    {
                        start: new THREE.Vector3(-70, pcbSurfaceY, 30),
                        end: new THREE.Vector3(
                            platterBase.baseWorldPos.x + 8,
                            Math.max(wireRouteY, platterBaseBox.min.y - 0.5),
                            platterBase.baseWorldPos.z
                        ),
                        color: 0x8b4513,
                        order: -0.4
                    }
                );
            }

            // Tonearm Pivot wires: Phono PCB → Tonearm Pivot (pivot base that allows needle arm to swing)
            if (tonearmPivot) {
                const pivotBox = new THREE.Box3().setFromObject(tonearmPivot.mesh);

                wireConfigs.push(
                    // Wire 1 (yellow - audio channel to tonearm pivot)
                    {
                        start: new THREE.Vector3(22, pcbSurfaceY, 15),
                        end: new THREE.Vector3(
                            tonearmPivot.baseWorldPos.x - 2,
                            Math.max(wireRouteY, pivotBox.min.y - 0.5),
                            tonearmPivot.baseWorldPos.z
                        ),
                        color: 0xffff00,
                        order: -0.6
                    },
                    // Wire 2 (green - audio channel to tonearm pivot)
                    {
                        start: new THREE.Vector3(32, pcbSurfaceY, 20),
                        end: new THREE.Vector3(
                            tonearmPivot.baseWorldPos.x + 2,
                            Math.max(wireRouteY, pivotBox.min.y - 0.5),
                            tonearmPivot.baseWorldPos.z
                        ),
                        color: 0x00ff00,
                        order: -0.6
                    }
                );
            }

            // Turntable Platter wires: Unitra PCB → Turntable Platter (knob with silver ring where it meets plate)
            if (turntablePlatter) {
                const platterBox = new THREE.Box3().setFromObject(turntablePlatter.mesh);

                wireConfigs.push(
                    // Wire 1 (magenta/pink - control signal to turntable platter)
                    {
                        start: new THREE.Vector3(-40, pcbSurfaceY, -10),
                        end: new THREE.Vector3(
                            spindle.baseWorldPos.x,
                            Math.max(wireRouteY, platterBox.min.y - 0.5),
                            spindle.baseWorldPos.z + 50
                        ),
                        color: 0xff00ff,
                        order: -0.4
                    },
                    // Wire 2 (cyan/turquoise - control signal to turntable platter)
                    {
                        start: new THREE.Vector3(-35, pcbSurfaceY, -5),
                        end: new THREE.Vector3(
                            spindle.baseWorldPos.x + 2,
                            Math.max(wireRouteY, platterBox.min.y - 0.5),
                            spindle.baseWorldPos.z + 52
                        ),
                        color: 0x00ffff,
                        order: -0.4
                    },

                    {
                        start: new THREE.Vector3(45, pcbSurfaceY, 5),
                        end: new THREE.Vector3(
                            spindle.baseWorldPos.x - 2,
                            Math.max(wireRouteY, platterBox.min.y - 0.5) - 7,
                            spindle.baseWorldPos.z + 85
                        ),
                        color: 0xff6699,
                        order: -0.6
                    },

                    {
                        start: new THREE.Vector3(37, pcbSurfaceY, 5),
                        end: new THREE.Vector3(
                            spindle.baseWorldPos.x,
                            Math.max(wireRouteY, platterBox.min.y - 0.5) - 7,
                            spindle.baseWorldPos.z + 82
                        ),
                        color: 0x999999,
                        order: -0.6
                    }
                );
            }

            wireConfigs.forEach((config, index) => {
                const wire = createWire(config.start, config.end, config.color);
                scene.add(wire);
                components.push({
                    mesh: wire,
                    parent: null,
                    order: config.order,
                    name: `Wire ${index + 1}`,
                    baseWorldPos: wire.position.clone(),
                    baseWorldQuat: wire.quaternion.clone(),
                    baseWorldScale: new THREE.Vector3(1, 1, 1),
                    baseLocalPos: wire.position.clone(),
                    baseLocalQuat: wire.quaternion.clone(),
                    baseLocalScale: new THREE.Vector3(1, 1, 1)
                });
            });

            // Hide loading, show controls
            document.getElementById('loading').style.display = 'none';
            document.getElementById('controls').style.display = 'flex';

            console.log(`Loaded ${components.length} components`);
        },
        (progress) => {
            const percent = progress.total > 0
                ? (progress.loaded / progress.total * 100).toFixed(0)
                : '...';
            document.getElementById('loading').textContent = `Loading model... ${percent}%`;
        },
        (error) => {
            console.error('Error loading model:', error);
            document.getElementById('loading').textContent = 'Error loading model';
        });

        // Button interaction
        document.getElementById('projectButton').addEventListener('click', () => {
            isExploded = !isExploded;
            const button = document.getElementById('projectButton');

            if (isExploded) {
                button.classList.add('active');
                animateCameraToFront();
            } else {
                button.classList.remove('active');
                animateCameraToClose();
            }
        });

        function animateCameraToFront() {
            // Animate camera to front view with full exploded anatomy in view
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();

            // Calculate dynamic camera position to fit entire exploded view in window
            // Bottom: Floor at 10 - (3 layers * 50) = -140
            // Top: Lid at ~40 + (7 layers * 50) = ~390
            // Total height: ~530 units
            // Center at: (-140 + 390) / 2 = ~125
            const endPos = new THREE.Vector3(0, 125, 800); // Zoomed out more
            const endTarget = new THREE.Vector3(0, 125, 300);

            let progress = 0;
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();

            function animateCamera() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);

                // Smooth easing
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                camera.position.lerpVectors(startPos, endPos, eased);
                controls.target.lerpVectors(startTarget, endTarget, eased);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            animateCamera();
        }

        function animateCameraToClose() {
            // Animate camera to closer view of reassembled model
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();

            // Zoom in to show full model with buffer space around it
            const endPos = new THREE.Vector3(0, 70, 280); // Closer but with buffer
            const endTarget = new THREE.Vector3(0, 40, 0); // Look at center of model

            let progress = 0;
            const duration = 1500; // 1.5 seconds
            const startTime = Date.now();

            function animateCamera() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / duration, 1);

                // Smooth easing
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                camera.position.lerpVectors(startPos, endPos, eased);
                controls.target.lerpVectors(startTarget, endTarget, eased);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }

            animateCamera();
        }

        function updateAnimation() {
            // Smooth animation towards target state
            const target = isExploded ? 1 : 0;
            const speed = 0.05;
            animationProgress += (target - animationProgress) * speed;

            components.forEach(comp => {
                // Calculate purely vertical offset - like a technical exploded diagram
                const explosionDistance = 50; // Distance per layer
                const verticalOffset = comp.order * explosionDistance * animationProgress;

                // Calculate target world position (only Y changes)
                const targetWorldPos = comp.baseWorldPos.clone();
                targetWorldPos.y += verticalOffset;

                // Convert world position back to local position
                if (comp.parent) {
                    const parentWorldMatrix = new THREE.Matrix4();
                    comp.parent.updateMatrixWorld();
                    parentWorldMatrix.copy(comp.parent.matrixWorld);

                    const parentWorldMatrixInverse = new THREE.Matrix4();
                    parentWorldMatrixInverse.copy(parentWorldMatrix).invert();

                    const localPos = targetWorldPos.clone().applyMatrix4(parentWorldMatrixInverse);
                    comp.mesh.position.copy(localPos);
                } else {
                    comp.mesh.position.copy(targetWorldPos);
                }

                // Maintain original rotation and scale
                comp.mesh.quaternion.copy(comp.baseLocalQuat);
                comp.mesh.scale.copy(comp.baseLocalScale);
            });
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateAnimation();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
