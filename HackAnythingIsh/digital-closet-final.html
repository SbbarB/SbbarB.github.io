<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Closet - Clueless Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.5/dist/teachablemachine-image.min.js"></script>
    <!-- MediaPipe loaded dynamically in code -->
    <!-- Three.js removed - not used -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .clothing-item {
            transition: all 0.3s ease;
        }

        .clothing-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .category-scroll {
            scroll-behavior: smooth;
        }

        .weather-widget {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.05);
        }

        .outfit-wheel {
            transition: transform 0.5s ease;
        }

        .spinning {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="gradient-bg min-h-screen">
    <!-- Navigation Header -->
    <nav class="glass sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-gradient-to-r from-pink-400 to-purple-600 rounded-full flex items-center justify-center">
                        <span class="text-white text-xl">‚ú®</span>
                    </div>
                    <div>
                        <h1 class="text-2xl font-bold text-white">Digital Closet</h1>
                        <div class="flex items-center gap-2">
                            <p class="text-pink-200 text-sm">Clueless Style AI</p>
                            <div id="modelStatus" class="text-xs px-2 py-1 rounded bg-yellow-500/20 text-yellow-200 flex items-center gap-1">
                                <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                                Loading Model...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Weather Widget -->
                <div id="weatherWidget" class="weather-widget px-4 py-2 rounded-full text-white font-medium">
                    <button onclick="getWeather()" class="flex items-center space-x-2">
                        <span id="weatherIcon">üå§Ô∏è</span>
                        <span id="weatherText">Get Weather</span>
                    </button>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="flex justify-center mt-4 space-x-2">
                <button onclick="showTab('closet')" id="tab-closet" class="tab-button active px-6 py-3 rounded-lg font-medium transition-all">
                    üëó My Closet
                </button>
                <button onclick="showTab('upload')" id="tab-upload" class="tab-button px-6 py-3 rounded-lg font-medium transition-all">
                    üì∏ Add Items
                </button>
                <button onclick="showTab('outfit')" id="tab-outfit" class="tab-button px-6 py-3 rounded-lg font-medium transition-all">
                    ‚ú® Pick Outfit
                </button>
                <button onclick="showTab('tryon')" id="tab-tryon" class="tab-button px-6 py-3 rounded-lg font-medium transition-all">
                    üé≠ Try On
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-6 py-8">

        <!-- Closet View -->
        <div id="closet-tab" class="tab-content">
            <div class="glass rounded-3xl p-8">
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-bold text-white mb-4">My Digital Closet</h2>
                    <p class="text-white/80 text-lg">
                        <span id="itemCount">0</span> items organized by AI ‚Ä¢
                        <button onclick="clearAllItems()" class="text-red-300 hover:text-red-200 underline ml-2">Clear All</button>
                    </p>
                </div>

                <!-- Category Filters -->
                <div class="mb-8">
                    <div class="flex flex-wrap justify-center gap-3">
                        <button onclick="filterCategory('all')" class="filter-btn active bg-white/20 text-white px-4 py-2 rounded-full">All</button>
                        <button onclick="filterCategory('shirt')" class="filter-btn bg-white/10 text-white/80 px-4 py-2 rounded-full">Tops</button>
                        <button onclick="filterCategory('pants')" class="filter-btn bg-white/10 text-white/80 px-4 py-2 rounded-full">Bottoms</button>
                        <button onclick="filterCategory('dress')" class="filter-btn bg-white/10 text-white/80 px-4 py-2 rounded-full">Dresses</button>
                        <button onclick="filterCategory('shoes')" class="filter-btn bg-white/10 text-white/80 px-4 py-2 rounded-full">Shoes</button>
                        <button onclick="filterCategory('jacket')" class="filter-btn bg-white/10 text-white/80 px-4 py-2 rounded-full">Outerwear</button>
                    </div>
                </div>

                <!-- Clothing Grid -->
                <div id="clothingGrid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                    <div class="col-span-full text-center py-16">
                        <div class="text-6xl mb-4">üëó</div>
                        <h3 class="text-2xl font-semibold text-white mb-2">Your closet is empty</h3>
                        <p class="text-white/70">Start by adding some clothing items!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Upload View -->
        <div id="upload-tab" class="tab-content hidden">
            <div class="glass rounded-3xl p-8">
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-bold text-white mb-4">Add Clothing Items</h2>
                    <p class="text-white/80 text-lg">Upload multiple images to quickly populate your closet</p>
                </div>

                <!-- Upload Area -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <div id="uploadArea" class="upload-area rounded-2xl p-8 text-center cursor-pointer h-80 flex flex-col items-center justify-center">
                            <div class="text-6xl mb-4">üì∏</div>
                            <h3 class="text-xl font-semibold text-white mb-2">Upload Images</h3>
                            <p class="text-white/70 mb-4">Click to select multiple clothing photos</p>
                            <div class="text-sm text-white/50">Supports: JPG, PNG, WEBP</div>
                        </div>
                        <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
                    </div>

                    <!-- Processing Results -->
                    <div id="processingArea" class="space-y-4">
                        <h3 class="text-xl font-semibold text-white">AI Classification</h3>
                        <div id="processingResults" class="bg-white/10 rounded-2xl p-6 h-64 overflow-y-auto">
                            <div class="text-center text-white/60 py-8">
                                <div class="text-4xl mb-2">ü§ñ</div>
                                <p>Select images to see AI classification results</p>
                            </div>
                        </div>
                        <button id="addItemsBtn" onclick="addProcessedItems()" class="w-full bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white py-3 rounded-xl font-semibold transition-all hidden">
                            Add Items to Closet
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Outfit Picker View -->
        <div id="outfit-tab" class="tab-content hidden">
            <div class="glass rounded-3xl p-8">
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-bold text-white mb-4">Pick Your Outfit</h2>
                    <p class="text-white/80 text-lg">AI-powered outfit selection based on weather and style</p>
                </div>

                <!-- Preferences Panel -->
                <div class="glass rounded-2xl p-6 mb-6">
                    <h3 class="text-xl font-semibold text-white mb-4 text-center">üé® Style Preferences</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Color Preferences -->
                        <div>
                            <label class="block text-white/80 text-sm mb-3">Preferred Colors</label>
                            <div class="flex flex-wrap gap-2">
                                <button onclick="toggleColorPreference('black')" class="color-pref bg-gray-800 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Black</button>
                                <button onclick="toggleColorPreference('white')" class="color-pref bg-gray-100 text-black px-3 py-2 rounded-full text-sm border-2 border-transparent">White</button>
                                <button onclick="toggleColorPreference('blue')" class="color-pref bg-blue-500 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Blue</button>
                                <button onclick="toggleColorPreference('red')" class="color-pref bg-red-500 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Red</button>
                                <button onclick="toggleColorPreference('green')" class="color-pref bg-green-500 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Green</button>
                                <button onclick="toggleColorPreference('gray')" class="color-pref bg-gray-500 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Gray</button>
                                <button onclick="toggleColorPreference('pink')" class="color-pref bg-pink-500 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Pink</button>
                                <button onclick="toggleColorPreference('purple')" class="color-pref bg-purple-500 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Purple</button>
                            </div>
                        </div>

                        <!-- Style Preferences -->
                        <div>
                            <label class="block text-white/80 text-sm mb-3">Preferred Styles</label>
                            <div class="flex flex-wrap gap-2">
                                <button onclick="toggleStylePreference('casual')" class="style-pref bg-white/20 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Casual</button>
                                <button onclick="toggleStylePreference('formal')" class="style-pref bg-white/20 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Formal</button>
                                <button onclick="toggleStylePreference('sporty')" class="style-pref bg-white/20 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Sporty</button>
                                <button onclick="toggleStylePreference('trendy')" class="style-pref bg-white/20 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Trendy</button>
                                <button onclick="toggleStylePreference('vintage')" class="style-pref bg-white/20 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Vintage</button>
                                <button onclick="toggleStylePreference('minimalist')" class="style-pref bg-white/20 text-white px-3 py-2 rounded-full text-sm border-2 border-transparent">Minimalist</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Weather Info Display -->
                <div id="weatherInfo" class="glass rounded-xl p-4 mb-6 text-center hidden">
                    <h4 class="text-white font-medium mb-2">üå§Ô∏è Current Weather</h4>
                    <div id="weatherDetails" class="text-white/80 text-sm"></div>
                </div>

                <!-- Smart Controls -->
                <div class="flex flex-wrap justify-center gap-4 mb-8">
                    <button onclick="generateSmartOutfit()" class="bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white px-8 py-4 rounded-xl font-bold text-lg transition-all transform hover:scale-105">
                        ‚ú® Smart Outfit
                    </button>
                    <button onclick="generateRandomOutfit()" class="bg-gradient-to-r from-blue-500 to-cyan-500 hover:from-blue-600 hover:to-cyan-600 text-white px-8 py-4 rounded-xl font-bold text-lg transition-all transform hover:scale-105">
                        üé≤ Random Pick
                    </button>
                    <button onclick="clearOutfit()" class="bg-gray-600 hover:bg-gray-700 text-white px-8 py-4 rounded-xl font-bold text-lg transition-all">
                        üîÑ Clear
                    </button>
                </div>

                <!-- Outfit Compatibility Score -->
                <div id="compatibilityScore" class="bg-white/10 rounded-2xl p-6 mb-8 text-center hidden">
                    <h3 class="text-xl font-semibold text-white mb-4">üíñ Outfit Compatibility</h3>
                    <div class="flex items-center justify-center gap-4">
                        <div class="w-48 h-3 bg-white/20 rounded-full overflow-hidden">
                            <div id="scoreBar" class="h-full bg-gradient-to-r from-pink-400 to-purple-500 transition-all duration-1000"></div>
                        </div>
                        <span id="scoreText" class="text-white font-bold text-xl">0%</span>
                    </div>
                </div>

                <!-- Outfit Categories -->
                <div id="outfitCategories" class="space-y-6">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Selected Outfit Preview -->
                <div id="selectedOutfitPreview" class="hidden bg-gradient-to-r from-purple-500/20 to-pink-500/20 rounded-2xl p-6 mt-8 border border-white/20">
                    <h3 class="text-2xl font-bold text-white mb-4 text-center">‚ú® Your Selected Outfit</h3>
                    <div id="outfitPreviewGrid" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Try On View -->
        <div id="tryon-tab" class="tab-content hidden">
            <!-- Fullscreen AR Try-On (when active) -->
            <div id="arFullscreen" class="fixed inset-0 z-50 hidden">
                <!-- Fullscreen Camera Video -->
                <video id="arCameraVideo" autoplay muted playsinline style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; z-index: 1;"></video>

                <!-- Canvas for 3D Clothing Overlay -->
                <canvas id="arOverlayCanvas" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none;"></canvas>

                <!-- AR Control Panels -->
                <div style="position: fixed; top: 16px; left: 16px; max-width: 300px; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); border-radius: 12px; padding: 16px; z-index: 10;">
                    <h2 class="text-lg font-semibold mb-3 text-white">üëó AR Clothing Try-On</h2>

                    <!-- Status -->
                    <div class="mb-4 text-sm space-y-1">
                        <div id="arPoseStatus">
                            <span class="arStatusDot" style="width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; background-color: #fbbf24; animation: pulse 1.5s infinite;"></span>
                            <span class="text-white">Pose Detection: Loading...</span>
                        </div>
                        <div id="arSegmentStatus">
                            <span class="arStatusDot" style="width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; background-color: #fbbf24; animation: pulse 1.5s infinite;"></span>
                            <span class="text-white">Object Detection: Loading...</span>
                        </div>
                        <div id="arMeshStatus">
                            <span class="arStatusDot" style="width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; background-color: #10b981;"></span>
                            <span class="text-white">3D Mesh: Ready</span>
                        </div>
                    </div>

                    <!-- Exit AR -->
                    <button onclick="exitAR()"
                            class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg transition-colors mb-3">
                        ‚ùå Exit AR Mode
                    </button>

                    <!-- Current Outfit Display -->
                    <div id="arCurrentOutfitDisplay" class="text-center text-white/60 mb-3">
                        <p class="text-sm">Current outfit will show here</p>
                    </div>
                </div>

                <!-- AR Controls Panel -->
                <div id="arControlsPanel" style="position: fixed; top: 16px; right: 16px; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); border-radius: 12px; padding: 16px; z-index: 10; display: none;">
                    <h3 class="text-lg font-semibold mb-3 text-white">üéÆ AR Controls</h3>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-sm mb-1 text-white">Scale: <span id="arScaleValue">1.0</span></label>
                            <input type="range" id="arScaleSlider" min="0.5" max="3" step="0.1" value="1"
                                   onchange="updateARClothingTransform()" class="w-full">
                        </div>
                        <div>
                            <label class="block text-sm mb-1 text-white">Offset Y: <span id="arOffsetValue">0</span></label>
                            <input type="range" id="arOffsetSlider" min="-100" max="100" step="5" value="0"
                                   onchange="updateARClothingTransform()" class="w-full">
                        </div>
                        <div>
                            <label class="block text-sm mb-1 text-white">Width: <span id="arWidthValue">1.0</span></label>
                            <input type="range" id="arWidthSlider" min="0.8" max="2.5" step="0.1" value="1.6"
                                   onchange="updateARClothingTransform()" class="w-full">
                        </div>
                        <div class="flex gap-2 mb-2">
                            <button onclick="toggleARClothing()" id="arToggleBtn"
                                    class="flex-1 bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded-lg transition-colors text-sm">
                                üëÅÔ∏è Toggle
                            </button>
                            <button onclick="resetARTransform()"
                                    class="flex-1 bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-2 rounded-lg transition-colors text-sm">
                                üîÑ Reset
                            </button>
                        </div>
                        <button onclick="toggleARDebugMode()" id="arDebugBtn"
                                class="w-full bg-gray-600 hover:bg-gray-700 text-white px-3 py-2 rounded-lg transition-colors text-sm">
                            üîß Debug
                        </button>
                    </div>
                </div>

                <!-- Debug Info -->
                <div style="position: fixed; bottom: 16px; right: 16px; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); border-radius: 12px; padding: 16px; z-index: 10; display: none;" id="arDebugInfo">
                    <div class="text-xs text-white space-y-1">
                        <div>FPS: <span id="arFpsCounter">0</span></div>
                        <div>Person Detected: <span id="arPersonDetected">‚ùå</span></div>
                        <div>Clothing Active: <span id="arClothingActive">‚ùå</span></div>
                        <div>Body Parts: <span id="arBodyParts">0</span></div>
                    </div>
                </div>

                <!-- Processing Status -->
                <div id="arProcessingStatus" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); border-radius: 12px; padding: 16px; z-index: 10; display: none;">
                    <div class="bg-gray-900 rounded-lg p-3">
                        <div class="flex items-center space-x-2 mb-2">
                            <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                            <span class="text-white text-sm" id="arProcessText">Processing...</span>
                        </div>
                        <div class="bg-gray-700 rounded-full h-2">
                            <div id="arProcessBar" class="bg-green-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Regular Try-On View -->
            <div class="glass rounded-3xl p-8">
                <div class="text-center mb-8">
                    <h2 class="text-4xl font-bold text-white mb-4">Virtual Try-On</h2>
                    <p class="text-white/80 text-lg">Experience your outfit with advanced AR technology</p>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- AR Preview -->
                    <div class="lg:col-span-2">
                        <div class="bg-black/30 rounded-2xl p-6 h-96 relative overflow-hidden">
                            <div class="flex flex-col items-center justify-center h-full text-white">
                                <div class="text-6xl mb-4">üé≠</div>
                                <h3 class="text-2xl font-semibold mb-4">AR Try-On Camera</h3>
                                <p class="text-white/70 mb-6 text-center">Start the AR camera to see your outfit in real-time</p>
                                <button onclick="startARTryOn()" class="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white px-8 py-4 rounded-xl font-semibold transition-all transform hover:scale-105">
                                    üöÄ Start AR Try-On
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Controls & Info -->
                    <div class="space-y-6">
                        <div class="glass rounded-xl p-4">
                            <h3 class="text-white font-semibold mb-3">üëó Current Outfit</h3>
                            <div id="currentOutfitDisplay" class="space-y-2">
                                <!-- Will be populated by JavaScript -->
                            </div>
                        </div>

                        <div class="glass rounded-xl p-4">
                            <h3 class="text-white font-semibold mb-3">‚ÑπÔ∏è How it Works</h3>
                            <div class="text-white/70 text-sm space-y-2">
                                <p>‚Ä¢ Select clothing items from your closet</p>
                                <p>‚Ä¢ Start the AR camera for real-time preview</p>
                                <p>‚Ä¢ Adjust fit and positioning with controls</p>
                                <p>‚Ä¢ AI tracks your body for realistic placement</p>
                            </div>
                        </div>

                        <div class="glass rounded-xl p-4">
                            <h3 class="text-white font-semibold mb-3">üîß Requirements</h3>
                            <div class="text-white/70 text-sm space-y-1">
                                <div id="cameraSupport">üìπ Camera: <span class="text-yellow-400">Checking...</span></div>
                                <div id="httpsSupport">üîí HTTPS: <span class="text-yellow-400">Checking...</span></div>
                                <div id="webglSupport">üéÆ WebGL: <span class="text-yellow-400">Checking...</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Item Modal -->
    <div id="editModal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4" onclick="if(event.target === this) closeEditModal()">
        <div class="glass rounded-3xl p-8 max-w-md w-full">
            <div class="flex items-center justify-between mb-6">
                <h2 class="text-2xl font-bold text-white">Edit Item</h2>
                <button onclick="closeEditModal()" class="text-white/70 hover:text-white text-2xl">√ó</button>
            </div>

            <div class="space-y-4">
                <div>
                    <label class="block text-white/80 text-sm mb-2">Category</label>
                    <select id="editCategory" class="w-full bg-white/10 text-white border border-white/20 rounded-lg px-4 py-2">
                        <option value="long sleeve shirt">Long Sleeve Shirt</option>
                        <option value="short sleeve shirt">Short Sleeve Shirt</option>
                        <option value="tank">Tank</option>
                        <option value="sweater">Sweater</option>
                        <option value="pants">Pants</option>
                        <option value="shorts">Shorts</option>
                        <option value="long skirt">Long Skirt</option>
                        <option value="short skirt">Short Skirt</option>
                        <option value="long dress">Long Dress</option>
                        <option value="short dress">Short Dress</option>
                        <option value="coat">Coat</option>
                        <option value="shoes">Shoes</option>
                        <option value="bag">Bag</option>
                        <option value="glasses">Glasses</option>
                    </select>
                </div>

                <div>
                    <label class="block text-white/80 text-sm mb-2">Color</label>
                    <input type="text" id="editColor" class="w-full bg-white/10 text-white border border-white/20 rounded-lg px-4 py-2" placeholder="e.g., blue, red, black">
                </div>

                <div>
                    <label class="block text-white/80 text-sm mb-2">Style</label>
                    <select id="editStyle" class="w-full bg-white/10 text-white border border-white/20 rounded-lg px-4 py-2">
                        <option value="casual">Casual</option>
                        <option value="formal">Formal</option>
                        <option value="athletic">Athletic</option>
                        <option value="trendy">Trendy</option>
                        <option value="vintage">Vintage</option>
                        <option value="minimalist">Minimalist</option>
                    </select>
                </div>

                <div>
                    <label class="block text-white/80 text-sm mb-2">Description (optional)</label>
                    <textarea id="editDescription" class="w-full bg-white/10 text-white border border-white/20 rounded-lg px-4 py-2 h-24 resize-none" placeholder="Add notes about this item..."></textarea>
                </div>

                <div class="flex gap-3 mt-6">
                    <button onclick="saveEditedItem(event)" class="flex-1 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white py-3 rounded-xl font-semibold transition-all">
                        Save Changes
                    </button>
                    <button onclick="closeEditModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-3 rounded-xl font-semibold transition-all">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let clothingItems = JSON.parse(localStorage.getItem('clueless-closet-items') || '[]');
        let currentWeather = null;
        let selectedOutfit = {};
        let model = null;
        let styleModel = null;
        let processedImages = [];
        let currentCamera = null;
        let userPreferences = {
            colors: JSON.parse(localStorage.getItem('preferred-colors') || '[]'),
            styles: JSON.parse(localStorage.getItem('preferred-styles') || '[]')
        };

        // Canvas pool for efficient image processing
        const canvasPool = [];
        const CANVAS_POOL_SIZE = 5;
        function getCanvas() {
            if (canvasPool.length > 0) {
                return canvasPool.pop();
            }
            const canvas = document.createElement('canvas');
            canvas.width = 224;
            canvas.height = 224;
            return canvas;
        }
        function releaseCanvas(canvas) {
            if (canvasPool.length < CANVAS_POOL_SIZE) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                canvasPool.push(canvas);
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Initializing Digital Closet app...');


            console.log('üéâ Digital Closet Loaded!');
            console.log('üìä Clothing items:', clothingItems.length);

            updateItemCount();
            renderClothingGrid();

            // Set initial model status
            updateModelStatus('loading');

            // Load AI model
            loadTeachableMachineModel();
            setupEventListeners();

            console.log('‚úÖ Event listeners set up');

            // Add demo items if closet is empty (for testing)
            if (clothingItems.length === 0) {
                console.log('üì¶ Adding demo items for testing...');
                addDemoItems();
            } else {
                console.log(`üìö Loaded ${clothingItems.length} existing items from storage`);
            }

            // Initialize preference buttons
            updatePreferenceButtons();

            console.log('‚úÖ App initialization complete!');
        });

        // Add demo items matching your model's exact categories
        function addDemoItems() {
            const demoItems = [
                {
                    id: Date.now() + 1,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzNzNkYyIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+U2hvcnQgU2xlZXZlPC90ZXh0Pjwvc3ZnPg==',
                    category: 'short sleeve shirt',
                    color: 'blue',
                    style: 'casual',
                    confidence: 0.9,
                    timestamp: Date.now()
                },
                {
                    id: Date.now() + 2,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzM3NDE1ZiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+UGFudHM8L3RleHQ+PC9zdmc+',
                    category: 'pants',
                    color: 'blue',
                    style: 'casual',
                    confidence: 0.85,
                    timestamp: Date.now()
                },
                {
                    id: Date.now() + 3,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzc5NzI3OSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+U2hvZXM8L3RleHQ+PC9zdmc+',
                    category: 'shoes',
                    color: 'white',
                    style: 'sporty',
                    confidence: 0.8,
                    timestamp: Date.now()
                },
                {
                    id: Date.now() + 4,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzJkNzI0YSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+Q29hdDwvdGV4dD48L3N2Zz4=',
                    category: 'coat',
                    color: 'green',
                    style: 'formal',
                    confidence: 0.88,
                    timestamp: Date.now()
                },
                {
                    id: Date.now() + 5,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2RjMjYyNiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+TG9uZyBEcmVzczwvdGV4dD48L3N2Zz4=',
                    category: 'long dress',
                    color: 'red',
                    style: 'formal',
                    confidence: 0.92,
                    timestamp: Date.now()
                },
                {
                    id: Date.now() + 6,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y5N2MxNiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+VGFuayBUb3A8L3RleHQ+PC9zdmc+',
                    category: 'tank top',
                    color: 'orange',
                    style: 'casual',
                    confidence: 0.87,
                    timestamp: Date.now()
                },
                {
                    id: Date.now() + 7,
                    image: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzkzMzM5MyIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+U2hvcnRzPC90ZXh0Pjwvc3ZnPg==',
                    category: 'shorts',
                    color: 'purple',
                    style: 'casual',
                    confidence: 0.89,
                    timestamp: Date.now()
                }
            ];

            // Only add demo items if localStorage is actually empty
            const stored = localStorage.getItem('clueless-closet-items');
            if (!stored || stored === '[]') {
                console.log('‚ú® Adding demo items for testing...', demoItems);
                clothingItems = demoItems;
                localStorage.setItem('clueless-closet-items', JSON.stringify(clothingItems));
                updateItemCount();
                renderClothingGrid();
                console.log('‚úÖ Demo items added successfully');
            }
        }

        // Wait for libraries to load
        function waitForLibraries() {
            return new Promise((resolve) => {
                const checkLibraries = () => {
                    if (typeof tf !== 'undefined' && typeof tmImage !== 'undefined') {
                        console.log('üìö Libraries loaded:', { tf: typeof tf, tmImage: typeof tmImage });
                        resolve();
                    } else {
                        console.log('‚è≥ Waiting for libraries...', { tf: typeof tf, tmImage: typeof tmImage });
                        setTimeout(checkLibraries, 500);
                    }
                };
                checkLibraries();
            });
        }

        // Load Teachable Machine Model
        async function loadTeachableMachineModel() {
            try {
                console.log('üîÑ Loading Teachable Machine models...');

                // Wait for libraries to be available
                await waitForLibraries();

                const itemModelURL = 'https://teachablemachine.withgoogle.com/models/jyXDTYz6M/model.json';
                const itemMetadataURL = 'https://teachablemachine.withgoogle.com/models/jyXDTYz6M/metadata.json';

                const styleModelURL = 'https://teachablemachine.withgoogle.com/models/18jaLQpyB/model.json';
                const styleMetadataURL = 'https://teachablemachine.withgoogle.com/models/18jaLQpyB/metadata.json';

                // Double-check libraries are available
                if (typeof tmImage === 'undefined') {
                    throw new Error('Teachable Machine Image library not available after waiting');
                }

                if (typeof tf === 'undefined') {
                    throw new Error('TensorFlow.js library not available after waiting');
                }

                console.log('üì• Loading item classification model from:', itemModelURL);
                model = await tmImage.load(itemModelURL, itemMetadataURL);
                console.log('‚úÖ Item model loaded successfully');
                console.log('üìã Item model class names:', model.getClassLabels());

                console.log('üì• Loading style classification model from:', styleModelURL);
                styleModel = await tmImage.load(styleModelURL, styleMetadataURL);
                console.log('‚úÖ Style model loaded successfully');
                console.log('üìã Style model class names:', styleModel.getClassLabels());

                // Add visual confirmation
                showNotification('AI models loaded successfully! Ready to classify clothing.', 'success');

                // Update status indicator
                updateModelStatus('loaded');
            } catch (error) {
                console.error('‚ùå Failed to load Teachable Machine models:', error);
                showNotification('Failed to load AI models. Classification will use fallback method.', 'warning');
                model = null;
                styleModel = null;

                // Update status indicator
                updateModelStatus('failed');
            }
        }

        // Add notification system for user feedback
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg text-white max-w-sm ${
                type === 'error' ? 'bg-red-500' :
                type === 'warning' ? 'bg-yellow-500' :
                type === 'success' ? 'bg-green-500' :
                'bg-blue-500'
            }`;
            notification.innerHTML = `
                <div class="flex items-center gap-2">
                    <span class="text-lg">${
                        type === 'error' ? '‚ùå' :
                        type === 'warning' ? '‚ö†Ô∏è' :
                        type === 'success' ? '‚úÖ' :
                        '‚ÑπÔ∏è'
                    }</span>
                    <p class="text-sm">${message}</p>
                </div>
            `;
            document.body.appendChild(notification);

            // Auto remove after 5 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 5000);
        }

        // Update model status indicator
        function updateModelStatus(status) {
            const statusElement = document.getElementById('modelStatus');
            if (!statusElement) return;

            switch (status) {
                case 'loading':
                    statusElement.innerHTML = `
                        <div class="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></div>
                        Loading Model...
                    `;
                    statusElement.className = 'text-xs px-2 py-1 rounded bg-yellow-500/20 text-yellow-200 flex items-center gap-1';
                    break;
                case 'loaded':
                    statusElement.innerHTML = `
                        <div class="w-2 h-2 bg-green-400 rounded-full"></div>
                        AI Ready
                    `;
                    statusElement.className = 'text-xs px-2 py-1 rounded bg-green-500/20 text-green-200 flex items-center gap-1';
                    break;
                case 'failed':
                    statusElement.innerHTML = `
                        <div class="w-2 h-2 bg-red-400 rounded-full"></div>
                        Model Failed
                    `;
                    statusElement.className = 'text-xs px-2 py-1 rounded bg-red-500/20 text-red-200 flex items-center gap-1';
                    break;
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Upload area click
            const uploadArea = document.getElementById('uploadArea');
            if (uploadArea) {
                uploadArea.addEventListener('click', () => {
                    document.getElementById('fileInput')?.click();
                });
            }

            // File input change
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }

            // AR controls - only if they exist
            const opacitySlider = document.getElementById('opacitySlider');
            if (opacitySlider) {
                opacitySlider.addEventListener('input', (e) => {
                    updateARSetting('opacity', e.target.value);
                });
            }

            const scaleSlider = document.getElementById('scaleSlider');
            if (scaleSlider) {
                scaleSlider.addEventListener('input', (e) => {
                    updateARSetting('scale', e.target.value);
                });
            }
        }

        // Tab Management
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });

            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.add('bg-white/10', 'text-white/80');
                btn.classList.remove('bg-white/20', 'text-white');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.remove('hidden');

            // Add active class to selected tab button
            const activeTab = document.getElementById('tab-' + tabName);
            activeTab.classList.add('active');
            activeTab.classList.remove('bg-white/10', 'text-white/80');
            activeTab.classList.add('bg-white/20', 'text-white');

            // Special actions for certain tabs
            if (tabName === 'outfit') {
                renderOutfitCategories();
            } else if (tabName === 'tryon') {
                displayCurrentOutfit();
            }
        }

        // Weather functionality with better permission handling
        async function getWeather() {
            console.log('üåç Requesting location for weather...');

            // Update UI to show loading state
            document.getElementById('weatherIcon').textContent = '‚è≥';
            document.getElementById('weatherText').textContent = 'Loading...';

            // Detect Safari for specific handling
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

            if (!navigator.geolocation) {
                console.warn('‚ö†Ô∏è Geolocation not supported by this browser');
                alert('Location services not supported by your browser. Using default weather.');
                useDefaultWeather();
                return;
            }

            // Safari often doesn't support permissions API for geolocation
            if (!isSafari && !isIOS && navigator.permissions) {
                try {
                    const permission = await navigator.permissions.query({ name: 'geolocation' });
                    console.log('üìç Geolocation permission status:', permission.state);

                    if (permission.state === 'denied') {
                        console.warn('‚ùå Location access permanently denied');
                        alert('Location access is blocked. Please enable location services in your browser settings, then refresh the page.');
                        useDefaultWeather();
                        return;
                    }
                } catch (e) {
                    console.log('üìç Permission API not available, proceeding with location request');
                }
            }

            // Safari-specific options (more generous timeout, less accuracy)
            const options = isSafari || isIOS ? {
                enableHighAccuracy: false,
                timeout: 15000, // Longer timeout for Safari
                maximumAge: 600000 // 10 minutes cache for Safari
            } : {
                enableHighAccuracy: false,
                timeout: 10000,
                maximumAge: 300000 // 5 minutes
            };

            console.log('üìç Location options:', options, { isSafari, isIOS });

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    console.log('‚úÖ Location obtained:', position.coords);

                    try {
                        // Use OpenWeatherMap API (free tier)
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;

                        // Get location name using reverse geocoding first to determine country
                        const geoResponse = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`);
                        const geoData = await geoResponse.json();

                        // Check if location is in the United States
                        const isUS = geoData.countryCode === 'US';
                        const temperatureUnit = isUS ? 'fahrenheit' : 'celsius';

                        // Use free weather API with appropriate temperature unit
                        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&temperature_unit=${temperatureUnit}&timezone=auto`);
                        const weatherData = await weatherResponse.json();

                        const weatherCondition = getWeatherCondition(weatherData.current_weather.weathercode);

                        const realWeather = {
                            temperature: Math.round(weatherData.current_weather.temperature),
                            temperatureUnit: isUS ? '¬∞F' : '¬∞C',
                            condition: weatherCondition,
                            location: geoData.city ? `${geoData.city}, ${geoData.countryName}` : `${lat.toFixed(2)}, ${lon.toFixed(2)}`,
                            windSpeed: weatherData.current_weather.windspeed
                        };

                        currentWeather = realWeather;
                        updateWeatherDisplay();
                        console.log('üå§Ô∏è Real weather updated based on location:', currentWeather);
                    } catch (apiError) {
                        console.error('‚ùå Weather API error:', apiError);
                        // Fallback to mock data if API fails
                        const mockWeather = {
                            temperature: Math.round(60 + Math.random() * 30),
                            temperatureUnit: '¬∞F',
                            condition: ['sunny', 'cloudy', 'rainy', 'partly-cloudy'][Math.floor(Math.random() * 4)],
                            location: `Location (${position.coords.latitude.toFixed(2)}, ${position.coords.longitude.toFixed(2)})`
                        };
                        currentWeather = mockWeather;
                        updateWeatherDisplay();
                        console.log('üå§Ô∏è Fallback weather used:', currentWeather);
                    }
                },
                (error) => {
                    console.error('‚ùå Location error:', error);
                    let message = '';

                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            if (isSafari || isIOS) {
                                message = 'üîí Safari Location Access: Please tap the "aA" button in Safari\'s address bar, select "Website Settings", and allow location access. Then refresh the page.';
                            } else {
                                message = 'Location access denied. Enable location services and refresh to get weather-based recommendations.';
                            }
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = 'Location information unavailable. Using default weather.';
                            break;
                        case error.TIMEOUT:
                            if (isSafari || isIOS) {
                                message = 'Location request timed out on Safari. This is common - using default weather.';
                            } else {
                                message = 'Location request timed out. Using default weather.';
                            }
                            break;
                        default:
                            message = 'Unknown location error. Using default weather.';
                            break;
                    }

                    console.warn('‚ö†Ô∏è', message);
                    alert(message);
                    useDefaultWeather();
                },
                options
            );
        }

        // Map weather codes to conditions
        function getWeatherCondition(weathercode) {
            const codeMap = {
                0: 'sunny',
                1: 'sunny',
                2: 'partly-cloudy',
                3: 'cloudy',
                45: 'cloudy',
                48: 'cloudy',
                51: 'rainy',
                53: 'rainy',
                55: 'rainy',
                56: 'rainy',
                57: 'rainy',
                61: 'rainy',
                63: 'rainy',
                65: 'rainy',
                66: 'rainy',
                67: 'rainy',
                71: 'snowy',
                73: 'snowy',
                75: 'snowy',
                77: 'snowy',
                80: 'rainy',
                81: 'rainy',
                82: 'rainy',
                85: 'snowy',
                86: 'snowy',
                95: 'stormy',
                96: 'stormy',
                99: 'stormy'
            };
            return codeMap[weathercode] || 'cloudy';
        }

        function useDefaultWeather() {
            currentWeather = {
                temperature: 72,
                temperatureUnit: '¬∞F',
                condition: 'partly-cloudy',
                location: 'Default Location'
            };
            updateWeatherDisplay();
            console.log('üå§Ô∏è Using default weather:', currentWeather);
        }

        function updateWeatherDisplay() {
            const iconMap = {
                'sunny': '‚òÄÔ∏è',
                'cloudy': '‚òÅÔ∏è',
                'rainy': 'üåßÔ∏è',
                'partly-cloudy': '‚õÖ',
                'snowy': '‚ùÑÔ∏è',
                'stormy': '‚õàÔ∏è'
            };

            document.getElementById('weatherIcon').textContent = iconMap[currentWeather.condition] || 'üå§Ô∏è';
            const tempUnit = currentWeather.temperatureUnit || '¬∞C';
            document.getElementById('weatherText').textContent = `${currentWeather.temperature}${tempUnit}`;

            // Update weather info panel
            const weatherInfo = document.getElementById('weatherInfo');
            const weatherDetails = document.getElementById('weatherDetails');

            weatherInfo.classList.remove('hidden');
            weatherDetails.innerHTML = `
                <p><strong>${currentWeather.temperature}${tempUnit}</strong> - ${currentWeather.condition.replace('-', ' ')}</p>
                ${currentWeather.location ? `<p class="text-xs mt-1">üìç ${currentWeather.location}</p>` : ''}
                <p class="text-xs mt-1">Smart outfit will consider weather conditions</p>
            `;
        }

        // Preference management functions
        function toggleColorPreference(color) {
            const index = userPreferences.colors.indexOf(color);
            if (index > -1) {
                userPreferences.colors.splice(index, 1);
            } else {
                userPreferences.colors.push(color);
            }
            localStorage.setItem('preferred-colors', JSON.stringify(userPreferences.colors));
            updatePreferenceButtons();
        }

        function toggleStylePreference(style) {
            const index = userPreferences.styles.indexOf(style);
            if (index > -1) {
                userPreferences.styles.splice(index, 1);
            } else {
                userPreferences.styles.push(style);
            }
            localStorage.setItem('preferred-styles', JSON.stringify(userPreferences.styles));
            updatePreferenceButtons();
        }

        function updatePreferenceButtons() {
            // Update color buttons
            document.querySelectorAll('.color-pref').forEach(button => {
                const color = button.textContent.toLowerCase();
                if (userPreferences.colors.includes(color)) {
                    button.classList.add('border-yellow-400');
                    button.classList.remove('border-transparent');
                } else {
                    button.classList.remove('border-yellow-400');
                    button.classList.add('border-transparent');
                }
            });

            // Update style buttons
            document.querySelectorAll('.style-pref').forEach(button => {
                const style = button.textContent.toLowerCase();
                if (userPreferences.styles.includes(style)) {
                    button.classList.add('border-yellow-400', 'bg-white/30');
                    button.classList.remove('border-transparent', 'bg-white/20');
                } else {
                    button.classList.remove('border-yellow-400', 'bg-white/30');
                    button.classList.add('border-transparent', 'bg-white/20');
                }
            });
        }

        // File Upload and Processing - Optimized for batch processing
        async function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            console.log(`üì¶ Processing ${files.length} images...`);

            processedImages = [];
            const resultsContainer = document.getElementById('processingResults');

            // Show progress indicator
            resultsContainer.innerHTML = `
                <div class="text-center text-white">
                    <div class="animate-spin text-2xl mb-2">‚ö°</div>
                    <p class="font-semibold">Processing ${files.length} images...</p>
                    <div class="mt-4 bg-white/20 rounded-full h-2">
                        <div id="uploadProgress" class="bg-green-500 h-2 rounded-full transition-all" style="width: 0%"></div>
                    </div>
                    <p class="text-sm mt-2"><span id="progressText">0 / ${files.length}</span> completed</p>
                </div>
            `;

            // Process images in batches of 3 for better performance
            const BATCH_SIZE = 3;
            let completed = 0;
            let failed = 0;

            for (let i = 0; i < files.length; i += BATCH_SIZE) {
                const batch = files.slice(i, i + BATCH_SIZE);

                // Process batch in parallel
                const batchPromises = batch.map(async (file, batchIndex) => {
                    try {
                        const imageData = await fileToDataURL(file);
                        const classification = await classifyImage(imageData);

                        const processedItem = {
                            id: Date.now() + i + batchIndex,
                            image: imageData,
                            filename: file.name,
                            ...classification
                        };

                        processedImages.push(processedItem);
                        completed++;

                        // Update progress
                        const progress = (completed / files.length) * 100;
                        const progressBar = document.getElementById('uploadProgress');
                        const progressText = document.getElementById('progressText');
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (progressText) progressText.textContent = `${completed} / ${files.length}`;

                        console.log(`‚úÖ Processed ${file.name} (${completed}/${files.length})`);
                    } catch (error) {
                        console.error('‚ùå Failed to process image:', file.name, error);
                        failed++;
                        completed++;

                        // Update progress even for failures
                        const progress = (completed / files.length) * 100;
                        const progressBar = document.getElementById('uploadProgress');
                        const progressText = document.getElementById('progressText');
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (progressText) progressText.textContent = `${completed} / ${files.length}`;
                    }
                });

                // Wait for batch to complete before starting next batch
                await Promise.all(batchPromises);
            }

            // Show final results
            console.log(`‚úÖ Processing complete: ${processedImages.length} successful, ${failed} failed`);
            updateProcessingResults();
            document.getElementById('addItemsBtn').classList.remove('hidden');

            if (failed > 0) {
                resultsContainer.innerHTML = `
                    <div class="text-center text-yellow-400 mb-4 p-3 bg-yellow-500/20 rounded-lg">
                        ‚ö†Ô∏è ${failed} image(s) failed to process
                    </div>
                ` + resultsContainer.innerHTML;
            }
        }

        async function classifyImage(imageData) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = async () => {
                    let canvas = null;
                    try {
                        if (model) {
                            // Get canvas from pool for efficient reuse
                            canvas = getCanvas();
                            const ctx = canvas.getContext('2d');

                            // Draw and resize the image to 224x224
                            ctx.drawImage(img, 0, 0, 224, 224);

                            // Get predictions from the item classification model
                            const itemPredictions = await model.predict(canvas);

                            // Sort predictions by probability and get top results
                            const sortedItemPredictions = itemPredictions.sort((a, b) => b.probability - a.probability);
                            const topItemPrediction = sortedItemPredictions[0];

                            // Clean up the category name (remove any extra spaces, make lowercase)
                            const category = topItemPrediction.className.toLowerCase().trim();
                            const confidence = topItemPrediction.probability;

                            // Get style from second model if available, otherwise use fallback
                            let style;
                            if (styleModel) {
                                const stylePredictions = await styleModel.predict(canvas);
                                const sortedStylePredictions = stylePredictions.sort((a, b) => b.probability - a.probability);
                                const topStylePrediction = sortedStylePredictions[0];
                                style = topStylePrediction.className.toLowerCase().trim();
                            } else {
                                // Fallback to determineStyle function if style model not loaded
                                style = determineStyle(category);
                            }

                            // Only proceed with classification if confidence is reasonable
                            if (confidence < 0.1) {
                                console.warn('‚ö†Ô∏è Low confidence prediction, using fallback');
                                resolve({
                                    category: 'clothing',
                                    confidence: confidence,
                                    color: await analyzeColor(img, 'clothing'),
                                    style: 'casual',
                                    timestamp: Date.now()
                                });
                                return;
                            }

                            // Determine color based on image analysis
                            const color = await analyzeColor(img, category);

                            const finalResult = {
                                category: category,
                                confidence: confidence,
                                color: color,
                                style: style,
                                timestamp: Date.now()
                            };

                            // Release canvas back to pool
                            if (canvas) releaseCanvas(canvas);

                            resolve(finalResult);
                        } else {
                            console.warn('‚ö†Ô∏è Models not loaded, using fallback classification');

                            // Enhanced fallback classification
                            resolve({
                                category: 'clothing',
                                confidence: 0.7,
                                color: await analyzeColor(img, 'clothing'),
                                style: 'casual',
                                timestamp: Date.now()
                            });
                        }
                    } catch (error) {
                        console.error('‚ùå Classification error:', error);

                        // Release canvas even on error
                        if (canvas) releaseCanvas(canvas);

                        resolve({
                            category: 'clothing',
                            confidence: 0.5,
                            color: 'unknown',
                            style: 'casual',
                            timestamp: Date.now()
                        });
                    }
                };
                img.crossOrigin = 'anonymous'; // Handle CORS issues
                img.src = imageData;
            });
        }

        // Advanced color analysis using canvas pixel data
        async function analyzeColor(img, category) {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                // Sample pixels from the center area (where clothing usually is)
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const sampleSize = Math.min(canvas.width, canvas.height) / 4;

                let r = 0, g = 0, b = 0, count = 0;

                // Sample pixels in a grid pattern
                for (let x = centerX - sampleSize/2; x < centerX + sampleSize/2; x += 10) {
                    for (let y = centerY - sampleSize/2; y < centerY + sampleSize/2; y += 10) {
                        if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                            const pixel = ctx.getImageData(x, y, 1, 1).data;
                            r += pixel[0];
                            g += pixel[1];
                            b += pixel[2];
                            count++;
                        }
                    }
                }

                if (count === 0) return 'unknown';

                r = Math.round(r / count);
                g = Math.round(g / count);
                b = Math.round(b / count);

                // Convert RGB to color name
                return rgbToColorName(r, g, b);
            } catch (error) {
                console.error('Color analysis error:', error);
                return 'blue'; // Default fallback
            }
        }

        // Convert RGB values to human-readable color names
        function rgbToColorName(r, g, b) {
            // Calculate color distances and determine closest color
            const colors = {
                'black': [0, 0, 0],
                'white': [255, 255, 255],
                'red': [255, 0, 0],
                'blue': [0, 0, 255],
                'green': [0, 128, 0],
                'yellow': [255, 255, 0],
                'purple': [128, 0, 128],
                'pink': [255, 192, 203],
                'orange': [255, 165, 0],
                'brown': [139, 69, 19],
                'gray': [128, 128, 128],
                'navy': [0, 0, 128],
                'beige': [245, 245, 220],
                'maroon': [128, 0, 0]
            };

            let closestColor = 'black';
            let minDistance = Infinity;

            for (const [colorName, [cr, cg, cb]] of Object.entries(colors)) {
                const distance = Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = colorName;
                }
            }

            return closestColor;
        }

        // Determine style based on category and context - Fallback function (style is now determined by second model)
        function determineStyle(category) {
            const categoryLower = category.toLowerCase();

            // Direct mapping for fallback when style model is not available
            // Categories match the new style model: Athletic, Casual, Formal, Trendy, Minimalist, Vintage
            const modelStyleMap = {
                // Formal items
                'long dress': 'formal',
                'short dress': 'formal',
                'coat': 'formal',

                // Casual items
                'long sleeve shirt': 'casual',
                'sweater': 'casual',
                'short sleeve shirt': 'casual',
                'tank': 'casual',
                'shorts': 'casual',
                'pants': 'casual',
                'long skirt': 'casual',
                'short skirt': 'casual',

                // Athletic
                'shoes': 'athletic',

                // Trendy/Accessories
                'bag': 'trendy',

                // Minimalist
                'glasses': 'minimalist'
            };

            // Check direct mapping first
            if (modelStyleMap[categoryLower]) {
                return modelStyleMap[categoryLower];
            }

            // Fallback style detection based on keywords
            const styleKeywords = {
                'formal': ['dress', 'coat', 'suit'],
                'casual': ['shirt', 'sleeve', 'sweater', 'tank', 'shorts', 'pants', 'skirt'],
                'athletic': ['athletic', 'sport', 'shoes', 'sneaker'],
                'trendy': ['bag', 'accessory', 'designer'],
                'minimalist': ['glasses', 'plain', 'simple', 'basic'],
                'vintage': ['vintage', 'retro', 'classic']
            };

            // Check keywords
            for (const [style, keywords] of Object.entries(styleKeywords)) {
                if (keywords.some(keyword => categoryLower.includes(keyword))) {
                    return style;
                }
            }

            // Smart defaults based on clothing type
            if (categoryLower.includes('dress')) {
                return 'formal';
            } else if (categoryLower.includes('sleeve') || categoryLower.includes('sweater')) {
                return 'casual';
            } else if (categoryLower.includes('tank') || categoryLower.includes('shorts')) {
                return 'casual';
            } else {
                return 'casual'; // Default fallback
            }
        }

        // Compress image to reduce localStorage size
        function compressImage(file, maxWidth = 800, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Calculate new dimensions
                        let width = img.width;
                        let height = img.height;

                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }

                        // Create canvas and compress
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert to compressed JPEG
                        const compressedDataURL = canvas.toDataURL('image/jpeg', quality);
                        console.log(`üìâ Compressed image: ${(e.target.result.length / 1024).toFixed(1)}KB ‚Üí ${(compressedDataURL.length / 1024).toFixed(1)}KB`);
                        resolve(compressedDataURL);
                    };
                    img.onerror = reject;
                    img.src = e.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function fileToDataURL(file) {
            // Use compression for storage efficiency
            return compressImage(file, 800, 0.7);
        }

        function updateProcessingResults() {
            const container = document.getElementById('processingResults');
            container.innerHTML = processedImages.map(item => `
                <div class="bg-white/20 rounded-lg p-3 mb-3 flex items-center space-x-3">
                    <img src="${item.image}" alt="${item.category}" class="w-12 h-12 object-cover rounded">
                    <div class="flex-1">
                        <p class="text-white font-medium capitalize">${item.category}</p>
                        <p class="text-white/70 text-sm">${Math.round(item.confidence * 100)}% ‚Ä¢ ${item.color} ‚Ä¢ ${item.style}</p>
                    </div>
                    <div class="text-green-400">‚úÖ</div>
                </div>
            `).join('');
        }

        async function addProcessedItems() {
            const addBtn = document.getElementById('addItemsBtn');
            const resultsContainer = document.getElementById('processingResults');

            // Show immediate feedback
            addBtn.disabled = true;
            addBtn.innerHTML = '‚è≥ Adding to closet...';

            // Give UI time to update before blocking operation
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                console.log(`üì¶ Adding ${processedImages.length} items to closet...`);

                // If user is adding their first real items, clear demo items
                const hasDemoItems = clothingItems.some(item =>
                    item.image && item.image.startsWith('data:image/svg+xml;base64')
                );

                if (hasDemoItems) {
                    console.log('üóëÔ∏è Removing demo items as user is adding real clothing');
                    clothingItems = clothingItems.filter(item =>
                        !(item.image && item.image.startsWith('data:image/svg+xml;base64'))
                    );
                }

                // Add items
                clothingItems = [...clothingItems, ...processedImages];

                // Save to localStorage
                try {
                    const dataSize = JSON.stringify(clothingItems).length;
                    console.log(`üíæ Saving ${clothingItems.length} items (${(dataSize / 1024).toFixed(1)}KB) to localStorage`);
                    localStorage.setItem('clueless-closet-items', JSON.stringify(clothingItems));
                    console.log('‚úÖ Items saved to localStorage');
                } catch (error) {
                    console.error('‚ùå localStorage error:', error);

                    // Provide helpful error message
                    const itemCount = clothingItems.length;
                    if (error.name === 'QuotaExceededError' || error.code === 22) {
                        alert(`‚ö†Ô∏è Storage limit reached!\n\nYou have ${itemCount} items which exceeds browser storage capacity.\n\nSuggestions:\n‚Ä¢ Remove older items you don't need\n‚Ä¢ The items ARE added to your closet, but won't save after refresh\n‚Ä¢ Consider downloading/backing up your closet`);
                    } else {
                        alert('Warning: Could not save to browser storage. Your items may not persist after refresh.');
                    }
                }

                // Clear processed images
                processedImages = [];

                // Update UI
                resultsContainer.innerHTML = `
                    <div class="text-center text-white py-8">
                        <div class="text-4xl mb-2">‚úÖ</div>
                        <p class="font-semibold">Items added to closet!</p>
                        <p class="text-sm text-white/70 mt-2">Check the "My Closet" tab to see your items</p>
                    </div>
                `;

                addBtn.classList.add('hidden');
                addBtn.disabled = false;
                addBtn.innerHTML = 'Add Items to Closet';
                document.getElementById('fileInput').value = '';

                // Update count immediately
                updateItemCount();

                // Render grid after a small delay to avoid blocking
                await new Promise(resolve => setTimeout(resolve, 100));
                renderClothingGrid();

                console.log('‚úÖ Successfully added items to closet');

            } catch (error) {
                console.error('‚ùå Error adding items:', error);
                alert('Error adding items to closet. Please try again.');
                addBtn.disabled = false;
                addBtn.innerHTML = 'Add Items to Closet';
            }
        }

        // Closet Management
        function updateItemCount() {
            document.getElementById('itemCount').textContent = clothingItems.length;
        }

        function renderClothingGrid() {
            const grid = document.getElementById('clothingGrid');

            if (clothingItems.length === 0) {
                grid.innerHTML = `
                    <div class="col-span-full text-center py-16">
                        <div class="text-6xl mb-4">üëó</div>
                        <h3 class="text-2xl font-semibold text-white mb-2">Your closet is empty</h3>
                        <p class="text-white/70">Start by adding some clothing items!</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = clothingItems.map(item => `
                <div class="clothing-item glass rounded-2xl p-4 group">
                    <div class="relative mb-3">
                        <img src="${item.image}" alt="${item.category}" class="w-full h-32 object-cover rounded-lg">
                        <div class="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-all">
                            <button onclick="editItem(${item.id})" class="bg-blue-500/80 hover:bg-blue-600 text-white p-1 rounded-full">
                                ‚úèÔ∏è
                            </button>
                            <button onclick="removeItem(${item.id})" class="bg-red-500/80 hover:bg-red-600 text-white p-1 rounded-full">
                                ‚ùå
                            </button>
                        </div>
                        <div class="absolute bottom-2 left-2 bg-black/60 px-2 py-1 rounded text-xs text-white">
                            ${Math.round(item.confidence * 100)}%
                        </div>
                    </div>
                    <h4 class="text-white font-medium capitalize text-sm">${item.category}</h4>
                    <p class="text-white/70 text-xs capitalize">${item.color} ‚Ä¢ ${item.style}</p>
                    ${item.description ? `<p class="text-white/60 text-xs mt-1 italic">${item.description}</p>` : ''}
                </div>
            `).join('');
        }

        function filterCategory(category) {
            // Update filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active', 'bg-white/20', 'text-white');
                btn.classList.add('bg-white/10', 'text-white/80');
            });
            event.target.classList.add('active', 'bg-white/20', 'text-white');
            event.target.classList.remove('bg-white/10', 'text-white/80');

            // Filter items
            const filteredItems = category === 'all' ? clothingItems :
                clothingItems.filter(item => item.category.toLowerCase().includes(category.toLowerCase()));

            const grid = document.getElementById('clothingGrid');
            if (filteredItems.length === 0) {
                grid.innerHTML = `
                    <div class="col-span-full text-center py-16">
                        <div class="text-4xl mb-4">üîç</div>
                        <h3 class="text-xl font-semibold text-white mb-2">No items found</h3>
                        <p class="text-white/70">Try a different category</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = filteredItems.map(item => `
                <div class="clothing-item glass rounded-2xl p-4 group">
                    <div class="relative mb-3">
                        <img src="${item.image}" alt="${item.category}" class="w-full h-32 object-cover rounded-lg">
                        <div class="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-all">
                            <button onclick="editItem(${item.id})" class="bg-blue-500/80 hover:bg-blue-600 text-white p-1 rounded-full">
                                ‚úèÔ∏è
                            </button>
                            <button onclick="removeItem(${item.id})" class="bg-red-500/80 hover:bg-red-600 text-white p-1 rounded-full">
                                ‚ùå
                            </button>
                        </div>
                        <div class="absolute bottom-2 left-2 bg-black/60 px-2 py-1 rounded text-xs text-white">
                            ${Math.round(item.confidence * 100)}%
                        </div>
                    </div>
                    <h4 class="text-white font-medium capitalize text-sm">${item.category}</h4>
                    <p class="text-white/70 text-xs capitalize">${item.color} ‚Ä¢ ${item.style}</p>
                    ${item.description ? `<p class="text-white/60 text-xs mt-1 italic">${item.description}</p>` : ''}
                </div>
            `).join('');
        }

        async function removeItem(id) {
            // Small delay for UI responsiveness
            await new Promise(resolve => setTimeout(resolve, 10));

            clothingItems = clothingItems.filter(item => item.id !== id);
            localStorage.setItem('clueless-closet-items', JSON.stringify(clothingItems));
            updateItemCount();

            // Small delay before heavy render
            await new Promise(resolve => setTimeout(resolve, 50));
            renderClothingGrid();
        }

        // Edit item functionality
        let currentEditingItemId = null;

        function editItem(id) {
            const item = clothingItems.find(item => item.id === id);
            if (!item) return;

            currentEditingItemId = id;

            // Populate modal with current values
            document.getElementById('editCategory').value = item.category;
            document.getElementById('editColor').value = item.color;
            document.getElementById('editStyle').value = item.style;
            document.getElementById('editDescription').value = item.description || '';

            // Show modal
            document.getElementById('editModal').classList.remove('hidden');
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.add('hidden');
            currentEditingItemId = null;
        }

        async function saveEditedItem(event) {
            if (!currentEditingItemId) return;

            const itemIndex = clothingItems.findIndex(item => item.id === currentEditingItemId);
            if (itemIndex === -1) return;

            // Get button and show immediate feedback
            const saveBtn = event ? event.target : null;
            let originalText = '';
            if (saveBtn) {
                originalText = saveBtn.innerHTML;
                saveBtn.disabled = true;
                saveBtn.innerHTML = '‚è≥ Saving...';
            }

            // Give UI time to update
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                // Update item with new values
                clothingItems[itemIndex].category = document.getElementById('editCategory').value;
                clothingItems[itemIndex].color = document.getElementById('editColor').value.toLowerCase();
                clothingItems[itemIndex].style = document.getElementById('editStyle').value;
                clothingItems[itemIndex].description = document.getElementById('editDescription').value;

                // Save to localStorage
                localStorage.setItem('clueless-closet-items', JSON.stringify(clothingItems));

                // Close modal first for immediate feedback
                closeEditModal();

                // Small delay before heavy render
                await new Promise(resolve => setTimeout(resolve, 100));

                // Update UI
                renderClothingGrid();

                console.log('‚úÖ Item updated successfully');
            } catch (error) {
                console.error('‚ùå Error saving item:', error);
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                }
                alert('Error saving changes. Please try again.');
            }
        }

        function clearAllItems() {
            if (confirm('Are you sure you want to clear all items from your closet?')) {
                clothingItems = [];
                localStorage.setItem('clueless-closet-items', JSON.stringify(clothingItems));
                updateItemCount();
                renderClothingGrid();
            }
        }

        // Outfit Generation
        function renderOutfitCategories() {
            const categories = {
                'tops': ['long sleeve shirt', 'short sleeve shirt', 'tank', 'sweater'],
                'bottoms': ['pants', 'shorts', 'long skirt', 'short skirt'],
                'dresses': ['long dress', 'short dress'],
                'outerwear': ['coat'],
                'shoes': ['shoes'],
                'accessories': ['bag', 'glasses']
            };

            const container = document.getElementById('outfitCategories');
            container.innerHTML = Object.entries(categories).map(([categoryName, keywords]) => {
                const categoryItems = clothingItems.filter(item =>
                    keywords.some(keyword => item.category.toLowerCase().includes(keyword))
                );

                if (categoryItems.length === 0) return '';

                return `
                    <div class="glass rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-xl font-semibold text-white capitalize">${categoryName}</h3>
                            <div class="flex space-x-2">
                                <button onclick="rotateCategory('${categoryName}', -1)" class="bg-white/20 hover:bg-white/30 text-white p-2 rounded-lg">‚Üê</button>
                                <button onclick="rotateCategory('${categoryName}', 1)" class="bg-white/20 hover:bg-white/30 text-white p-2 rounded-lg">‚Üí</button>
                            </div>
                        </div>
                        <div id="category-${categoryName}" class="outfit-wheel text-center">
                            ${selectedOutfit[categoryName] ? `
                                <div class="bg-white/20 rounded-lg p-4 inline-block">
                                    <img src="${selectedOutfit[categoryName].image}" alt="${selectedOutfit[categoryName].category}" class="w-24 h-24 object-cover rounded-lg mx-auto mb-2">
                                    <p class="text-white font-medium capitalize">${selectedOutfit[categoryName].category}</p>
                                    <p class="text-white/70 text-sm">${selectedOutfit[categoryName].color} ‚Ä¢ ${selectedOutfit[categoryName].style}</p>
                                </div>
                            ` : `
                                <div class="border-2 border-dashed border-white/30 rounded-lg p-8 text-center">
                                    <div class="text-4xl mb-2">üëó</div>
                                    <p class="text-white/60">No ${categoryName} selected</p>
                                </div>
                            `}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function generateSmartOutfit() {
            if (clothingItems.length === 0) {
                alert('Add some clothing items first!');
                return;
            }

            console.log('Generating smart outfit with items:', clothingItems);
            console.log('User preferences:', userPreferences);

            // Updated category mapping to match YOUR specific Teachable Machine model
            const categories = {
                'tops': ['long sleeve shirt', 'short sleeve shirt', 'tank', 'sweater'],
                'bottoms': ['pants', 'shorts', 'long skirt', 'short skirt'],
                'dresses': ['long dress', 'short dress'],
                'outerwear': ['coat'],
                'shoes': ['shoes'],
                'accessories': ['bag', 'glasses']
            };

            // Check if we have essential items (top and bottom OR dress)
            const hasTop = clothingItems.some(item => {
                const itemCategory = item.category.toLowerCase();
                return categories['tops'].some(keyword =>
                    itemCategory.includes(keyword) || itemCategory === keyword || keyword.includes(itemCategory)
                );
            });

            const hasBottom = clothingItems.some(item => {
                const itemCategory = item.category.toLowerCase();
                return categories['bottoms'].some(keyword =>
                    itemCategory.includes(keyword) || itemCategory === keyword || keyword.includes(itemCategory)
                );
            });

            const hasDress = clothingItems.some(item => {
                const itemCategory = item.category.toLowerCase();
                return categories['dresses'].some(keyword =>
                    itemCategory.includes(keyword) || itemCategory === keyword || keyword.includes(itemCategory)
                );
            });

            if (!(hasTop && hasBottom) && !hasDress) {
                alert('You need at least a top and bottom OR a dress to create an outfit!');
                return;
            }

            selectedOutfit = {};
            let outfitGenerated = false;

            Object.entries(categories).forEach(([categoryName, keywords]) => {
                const categoryItems = clothingItems.filter(item => {
                    const itemCategory = item.category.toLowerCase();
                    return keywords.some(keyword =>
                        itemCategory.includes(keyword) ||
                        itemCategory === keyword ||
                        keyword.includes(itemCategory)
                    );
                });

                console.log(`${categoryName} items:`, categoryItems);

                if (categoryItems.length > 0) {
                    // Smart selection based on weather, color, style, and user preferences
                    let scoredItems = categoryItems.map(item => {
                        let score = (item.confidence || 0.8) * 100;

                        // User color preferences (HIGH PRIORITY)
                        if (userPreferences.colors.length > 0) {
                            if (userPreferences.colors.includes(item.color)) {
                                score += 50; // Major bonus for preferred colors
                            }
                        }

                        // User style preferences (HIGH PRIORITY)
                        if (userPreferences.styles.length > 0) {
                            if (userPreferences.styles.includes(item.style)) {
                                score += 40; // Major bonus for preferred styles
                            }
                        }

                        // Weather considerations (MEDIUM PRIORITY)
                        if (currentWeather) {
                            const temp = currentWeather.temperature;

                            if (temp < 15) {
                                // Cold weather preferences
                                if (categoryName === 'outerwear') score += 35;
                                if (categoryName === 'bottoms' && (item.category.includes('pants') || item.category.includes('jeans'))) score += 25;
                                if (['black', 'gray', 'navy', 'brown'].includes(item.color)) score += 15;
                                // Discourage shorts/tank tops in cold weather
                                if (item.category.includes('shorts') || item.category.includes('tank')) score -= 30;
                            } else if (temp > 25) {
                                // Hot weather preferences
                                if (categoryName === 'tops' && (item.category.includes('tank') || item.category.includes('t-shirt'))) score += 30;
                                if (categoryName === 'bottoms' && (item.category.includes('shorts') || item.category.includes('skirt'))) score += 25;
                                if (['white', 'yellow', 'pink', 'beige'].includes(item.color)) score += 15;
                                // Discourage heavy items in hot weather
                                if (item.category.includes('jacket') || item.category.includes('sweater')) score -= 25;
                            } else {
                                // Mild weather - balance
                                score += 5;
                            }

                            // Rain considerations
                            if (currentWeather.condition === 'rainy') {
                                if (categoryName === 'outerwear') score += 30;
                                if (categoryName === 'shoes' && item.category.includes('boots')) score += 20;
                            }
                        }

                        // Style consistency bonus (if we already have items selected)
                        const existingStyles = Object.values(selectedOutfit).map(i => i.style);
                        if (existingStyles.length > 0 && existingStyles.includes(item.style)) {
                            score += 20;
                        }

                        // Color coordination bonus
                        const existingColors = Object.values(selectedOutfit).map(i => i.color);
                        if (existingColors.length > 0) {
                            if (existingColors.includes(item.color)) score += 15;
                            if (['black', 'white', 'gray'].includes(item.color)) score += 10; // Neutral colors
                        }

                        return { ...item, score };
                    });

                    scoredItems.sort((a, b) => b.score - a.score);
                    selectedOutfit[categoryName] = scoredItems[0];
                    outfitGenerated = true;
                }
            });

            console.log('Generated outfit:', selectedOutfit);

            // Validate we have essential pieces
            const hasSelectedTop = selectedOutfit['tops'];
            const hasSelectedBottom = selectedOutfit['bottoms'];
            const hasSelectedDress = selectedOutfit['dresses'];

            if (!(hasSelectedTop && hasSelectedBottom) && !hasSelectedDress) {
                alert('Could not create a complete outfit. Make sure you have both tops and bottoms OR dresses!');
                return;
            }

            if (outfitGenerated) {
                renderOutfitCategories();
                updateCompatibilityScore();
                showSelectedOutfitPreview();
            } else {
                alert('No compatible clothing items found. Try adding more diverse clothing types!');
            }
        }

        function generateRandomOutfit() {
            if (clothingItems.length === 0) {
                alert('Add some clothing items first!');
                return;
            }

            console.log('Generating random outfit with items:', clothingItems);

            // Updated category mapping to match YOUR specific Teachable Machine model
            const categories = {
                'tops': ['long sleeve shirt', 'short sleeve shirt', 'tank', 'sweater'],
                'bottoms': ['pants', 'shorts', 'long skirt', 'short skirt'],
                'dresses': ['long dress', 'short dress'],
                'outerwear': ['coat'],
                'shoes': ['shoes'],
                'accessories': ['bag', 'glasses']
            };

            selectedOutfit = {};
            let outfitGenerated = false;

            Object.entries(categories).forEach(([categoryName, keywords]) => {
                const categoryItems = clothingItems.filter(item => {
                    const itemCategory = item.category.toLowerCase();
                    return keywords.some(keyword =>
                        itemCategory.includes(keyword) ||
                        itemCategory === keyword ||
                        keyword.includes(itemCategory)
                    );
                });

                if (categoryItems.length > 0) {
                    selectedOutfit[categoryName] = categoryItems[Math.floor(Math.random() * categoryItems.length)];
                    outfitGenerated = true;
                }
            });

            console.log('Generated random outfit:', selectedOutfit);

            if (outfitGenerated) {
                renderOutfitCategories();
                updateCompatibilityScore();
                showSelectedOutfitPreview();
            } else {
                alert('No clothing items found to create an outfit!');
            }
        }

        function rotateCategory(categoryName, direction) {
            const keywords = {
                'tops': ['long sleeve shirt', 'short sleeve shirt', 'tank top', 'sweater'],
                'bottoms': ['pants', 'shorts', 'long skirt', 'short skirt'],
                'dresses': ['long dress', 'short dress'],
                'outerwear': ['coat'],
                'shoes': ['shoes'],
                'accessories': ['bag', 'glasses']
            }[categoryName];

            if (!keywords) return;

            const categoryItems = clothingItems.filter(item => {
                const itemCategory = item.category.toLowerCase();
                return keywords.some(keyword =>
                    itemCategory.includes(keyword) ||
                    itemCategory === keyword ||
                    keyword.includes(itemCategory)
                );
            });

            if (categoryItems.length <= 1) return;

            const currentItem = selectedOutfit[categoryName];
            const currentIndex = currentItem ? categoryItems.findIndex(item => item.id === currentItem.id) : -1;

            let newIndex;
            if (direction === 1) {
                newIndex = currentIndex >= categoryItems.length - 1 ? 0 : currentIndex + 1;
            } else {
                newIndex = currentIndex <= 0 ? categoryItems.length - 1 : currentIndex - 1;
            }

            selectedOutfit[categoryName] = categoryItems[newIndex];

            // Add spinning animation
            const categoryElement = document.getElementById(`category-${categoryName}`);
            if (categoryElement) {
                categoryElement.classList.add('spinning');
                setTimeout(() => {
                    categoryElement.classList.remove('spinning');
                    renderOutfitCategories();
                    updateCompatibilityScore();
                    showSelectedOutfitPreview();
                }, 500);
            }
        }

        function clearOutfit() {
            selectedOutfit = {};
            renderOutfitCategories();
            document.getElementById('compatibilityScore').classList.add('hidden');
            document.getElementById('selectedOutfitPreview').classList.add('hidden');
        }

        function updateCompatibilityScore() {
            const outfitItems = Object.values(selectedOutfit);
            if (outfitItems.length < 2) {
                document.getElementById('compatibilityScore').classList.add('hidden');
                return;
            }

            let score = 0;

            // Color harmony
            const colors = outfitItems.map(item => item.color);
            const uniqueColors = [...new Set(colors)];
            if (uniqueColors.length <= 3) score += 30;
            if (colors.includes('white') || colors.includes('black')) score += 20;

            // Style consistency
            const styles = outfitItems.map(item => item.style);
            const uniqueStyles = [...new Set(styles)];
            if (uniqueStyles.length <= 2) score += 25;

            // Weather appropriateness
            if (currentWeather) {
                if (currentWeather.temperature < 15 && outfitItems.some(item =>
                    item.category.includes('jacket') || item.category.includes('pants')
                )) score += 20;

                if (currentWeather.temperature > 25 && outfitItems.some(item =>
                    item.category.includes('shorts') || item.category.includes('tank')
                )) score += 20;
            }

            // Average confidence
            const avgConfidence = outfitItems.reduce((sum, item) => sum + item.confidence, 0) / outfitItems.length;
            score += avgConfidence * 15;

            score = Math.min(100, Math.max(0, score));

            document.getElementById('scoreBar').style.width = `${score}%`;
            document.getElementById('scoreText').textContent = `${Math.round(score)}%`;
            document.getElementById('compatibilityScore').classList.remove('hidden');
        }

        function showSelectedOutfitPreview() {
            const outfitItems = Object.values(selectedOutfit);
            if (outfitItems.length === 0) {
                document.getElementById('selectedOutfitPreview').classList.add('hidden');
                return;
            }

            const previewGrid = document.getElementById('outfitPreviewGrid');
            previewGrid.innerHTML = outfitItems.map(item => `
                <div class="text-center">
                    <img src="${item.image}" alt="${item.category}" class="w-20 h-20 object-cover rounded-lg mx-auto mb-2">
                    <p class="text-white text-sm capitalize">${item.category}</p>
                </div>
            `).join('');

            document.getElementById('selectedOutfitPreview').classList.remove('hidden');
        }

        // AR Try-On functionality
        function displayCurrentOutfit() {
            const outfitItems = Object.values(selectedOutfit);
            const container = document.getElementById('currentOutfitDisplay');

            if (outfitItems.length === 0) {
                container.innerHTML = `
                    <p class="text-white/60">No outfit selected</p>
                    <p class="text-sm mt-2">Go to "Pick Outfit" first</p>
                `;
                return;
            }

            container.innerHTML = `
                <div class="grid grid-cols-2 gap-2">
                    ${outfitItems.map(item => `
                        <div class="text-center">
                            <img src="${item.image}" alt="${item.category}" class="w-12 h-12 object-cover rounded mx-auto mb-1">
                            <p class="text-white text-xs capitalize">${item.category}</p>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        async function startCamera() {
            try {
                console.log('üìπ Starting camera...');

                // Detect Safari and iOS
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                console.log('üìç Browser support check:', {
                    mediaDevices: !!navigator.mediaDevices,
                    getUserMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia),
                    userAgent: navigator.userAgent,
                    isSafari: isSafari,
                    isIOS: isIOS,
                    isMobile: isMobile
                });

                // Check if page is served over HTTPS (required for camera access)
                if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                    const httpsUrl = window.location.href.replace('http://', 'https://');
                    showNotification('Camera requires HTTPS. Run the HTTPS server script!', 'error');
                    throw new Error(`Camera access requires HTTPS. Please use: https://localhost:8443/clueless-digital-closet.html`);
                }

                // Check if mediaDevices API is available
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    // Try legacy getUserMedia for older browsers
                    const legacyGetUserMedia = navigator.getUserMedia ||
                                              navigator.webkitGetUserMedia ||
                                              navigator.mozGetUserMedia ||
                                              navigator.msGetUserMedia;

                    if (legacyGetUserMedia) {
                        console.log('üìπ Using legacy getUserMedia');
                        return startCameraLegacy();
                    }
                    throw new Error('Camera API not supported by this browser');
                }

                // For Safari, ensure this is triggered by a user gesture
                if (isSafari || isIOS) {
                    console.log('üì± Safari detected - ensuring user gesture initiated camera request');
                }

                // Skip permission check for Safari as it's not reliable
                if (!isSafari && navigator.permissions) {
                    try {
                        const permission = await navigator.permissions.query({ name: 'camera' });
                        console.log('üìπ Camera permission status:', permission.state);

                        if (permission.state === 'denied') {
                            throw new Error('Camera access is permanently blocked. Please enable camera permissions in your browser settings and refresh the page.');
                        }
                    } catch (e) {
                        console.log('üìπ Permission API not available, proceeding with camera request');
                    }
                }

                // Safari and iOS specific constraints (more lenient)
                let constraints;
                if (isSafari || isIOS) {
                    constraints = {
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        },
                        audio: false
                    };
                    console.log('üìπ Using Safari/iOS optimized constraints');
                } else {
                    constraints = {
                        video: {
                            width: { ideal: 640, max: 1280 },
                            height: { ideal: 480, max: 720 },
                            facingMode: 'user',
                            frameRate: { ideal: 30, max: 30 }
                        },
                        audio: false
                    };
                }

                console.log('üìπ Requesting camera with constraints:', constraints);

                let stream;
                try {
                    console.log('üìπ Attempting getUserMedia with constraints:', constraints);
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('‚úÖ getUserMedia succeeded with full constraints');
                } catch (constraintError) {
                    console.warn('üìπ Failed with full constraints, trying basic constraints:', constraintError);

                    // For Safari, try even more basic constraints
                    let basicConstraints;
                    if (isSafari || isIOS) {
                        basicConstraints = { video: true, audio: false };
                    } else {
                        basicConstraints = { video: { facingMode: 'user' }, audio: false };
                    }

                    try {
                        console.log('üìπ Trying basic constraints:', basicConstraints);
                        stream = await navigator.mediaDevices.getUserMedia(basicConstraints);
                        console.log('‚úÖ getUserMedia succeeded with basic constraints');
                    } catch (basicError) {
                        console.error('‚ùå Even basic constraints failed:', basicError);
                        throw basicError;
                    }
                }

                const video = document.getElementById('arVideo');
                const canvas = document.getElementById('arCanvas');
                const button = document.getElementById('startCameraBtn');
                const cameraArea = document.getElementById('arCameraArea');

                console.log('‚úÖ Camera stream obtained:', {
                    videoTracks: stream.getVideoTracks().length,
                    activeTrack: stream.getVideoTracks()[0]?.getSettings()
                });

                video.srcObject = stream;
                video.classList.remove('hidden');
                button.style.display = 'none';

                // Safari-specific video setup
                if (isSafari || isIOS) {
                    video.setAttribute('webkit-playsinline', 'true');
                    video.setAttribute('playsInline', 'true');
                    video.muted = true;
                    video.defaultMuted = true;
                }

                // Wait for video to be ready
                const onVideoReady = () => {
                    console.log('üìπ Video metadata loaded:', {
                        videoWidth: video.videoWidth,
                        videoHeight: video.videoHeight,
                        duration: video.duration
                    });

                    const startPlayback = () => {
                        video.play().then(() => {
                            console.log('‚ñ∂Ô∏è Video started playing');
                            canvas.width = video.videoWidth || 640;
                            canvas.height = video.videoHeight || 480;

                            // Start AR rendering loop
                            currentCamera = stream;
                            renderAROverlay();
                        }).catch(e => {
                            console.error('‚ùå Failed to start video playback:', e);
                            if (isSafari || isIOS) {
                                // For Safari, try a user gesture workaround
                                console.log('üìπ Safari detected - requiring user interaction for video play');
                                const playPrompt = document.createElement('div');
                                playPrompt.innerHTML = `
                                    <div class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-20">
                                        <button class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg text-lg">
                                            üì± Tap to Start Camera
                                        </button>
                                    </div>
                                `;
                                playPrompt.onclick = () => {
                                    video.play();
                                    playPrompt.remove();
                                };
                                cameraArea.appendChild(playPrompt);
                            } else {
                                alert('Failed to start video playback. Please try again.');
                            }
                        });
                    };

                    // For Safari, add a small delay to ensure proper initialization
                    if (isSafari || isIOS) {
                        setTimeout(startPlayback, 100);
                    } else {
                        startPlayback();
                    }
                };

                video.onloadedmetadata = onVideoReady;

                // Additional Safari-specific event listeners
                if (isSafari || isIOS) {
                    video.oncanplay = () => {
                        console.log('üìπ Video can play');
                        if (video.readyState >= 2) {
                            onVideoReady();
                        }
                    };
                }

                // Handle video loading errors with Safari-specific messaging
                video.onerror = (e) => {
                    console.error('‚ùå Video element error:', e);
                    if (isSafari || isIOS) {
                        alert('Video loading error on Safari. Please ensure camera permissions are enabled and try refreshing the page.');
                    } else {
                        alert('Video loading error. Please refresh and try again.');
                    }
                };

                // Add stop camera button
                const existingStopBtn = cameraArea.querySelector('.stop-camera-btn');
                if (!existingStopBtn) {
                    const stopBtn = document.createElement('button');
                    stopBtn.innerHTML = '‚ùå Stop Camera';
                    stopBtn.className = 'stop-camera-btn absolute top-4 right-4 bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg z-10';
                    stopBtn.onclick = stopCamera;
                    cameraArea.appendChild(stopBtn);
                }

            } catch (error) {
                console.error('‚ùå Camera error:', error);

                let message = '';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    if (isSafari || isIOS) {
                        message = 'üîí Safari Camera Access Denied:\n\n1. Look for the camera icon in Safari\'s address bar (URL bar)\n2. Tap/click it and select "Allow"\n3. If no icon appears, go to Safari > Settings for This Website > Camera > Allow\n4. On iOS: Check Settings > Safari > Camera & Microphone Access\n5. Refresh the page and try again\n\nNote: You must click the "Start Camera" button for the permission prompt to appear.';
                    } else {
                        message = 'Camera access denied. Please click the camera icon in your browser\'s address bar and allow camera access, then refresh the page.';
                    }
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    message = 'No camera found. Please connect a camera and try again.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    if (isSafari || isIOS) {
                        message = 'üì± Camera busy: Close other apps using the camera (like FaceTime, Camera app, or other browser tabs) and try again.';
                    } else {
                        message = 'Camera is already in use by another application. Please close other camera applications and try again.';
                    }
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    message = 'Camera does not support the required settings. Try refreshing the page.';
                } else if (error.name === 'NotSupportedError') {
                    message = 'Camera access is not supported by this browser. Try using Chrome, Firefox, or Safari.';
                } else if (error.name === 'SecurityError') {
                    message = 'Camera access blocked for security reasons. Make sure you\'re using HTTPS or localhost.';
                } else {
                    if (isSafari || isIOS) {
                        message = `üîß Safari Camera Error: ${error.message}. Try refreshing the page or restarting Safari.`;
                    } else {
                        message = `Camera error: ${error.message}`;
                    }
                }

                console.error('üìπ Detailed camera error:', { name: error.name, message: error.message, constraint: error.constraint });

                // For Safari, show a more user-friendly prompt
                if ((isSafari || isIOS) && (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError')) {
                    showSafariCameraHelp();
                } else {
                    alert(message);
                }
            }
        }

        // Safari-specific camera permission help
        function showSafariCameraHelp() {
            const helpDiv = document.createElement('div');
            helpDiv.innerHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50" style="z-index: 9999;">
                    <div class="bg-white rounded-lg p-6 max-w-md mx-4 text-black">
                        <h3 class="text-lg font-bold mb-4">üîí Safari Camera Access</h3>
                        <div class="space-y-3 text-sm">
                            <p><strong>Step 1:</strong> Look for the camera icon üì∑ in Safari's address bar</p>
                            <p><strong>Step 2:</strong> Tap/click it and select "Allow"</p>
                            <p><strong>Step 3:</strong> If no icon appears, tap "aA" ‚Üí "Website Settings" ‚Üí Camera ‚Üí "Allow"</p>
                            <p><strong>iOS Users:</strong> Check Settings ‚Üí Safari ‚Üí Camera & Microphone Access</p>
                            <p><strong>Step 4:</strong> Refresh the page and try again</p>
                        </div>
                        <div class="flex gap-2 mt-6">
                            <button onclick="location.reload()" class="flex-1 bg-blue-600 text-white px-4 py-2 rounded">
                                üîÑ Refresh Page
                            </button>
                            <button onclick="this.closest('div').remove()" class="flex-1 bg-gray-600 text-white px-4 py-2 rounded">
                                ‚úï Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(helpDiv);
        }

        function stopCamera() {
            console.log('üõë Stopping camera...');

            if (currentCamera) {
                // Stop all camera tracks
                currentCamera.getTracks().forEach(track => {
                    track.stop();
                    console.log('üõë Stopped track:', track.kind);
                });
                currentCamera = null;

                const video = document.getElementById('arVideo');
                const canvas = document.getElementById('arCanvas');
                const button = document.getElementById('startCameraBtn');
                const cameraArea = document.getElementById('arCameraArea');

                // Reset video element
                video.classList.add('hidden');
                video.srcObject = null;
                video.onloadedmetadata = null;
                video.onerror = null;

                // Show start button again
                button.style.display = 'block';

                // Clear canvas
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Remove stop button
                const stopBtn = cameraArea.querySelector('.stop-camera-btn');
                if (stopBtn) {
                    stopBtn.remove();
                    console.log('üõë Stop button removed');
                }

                console.log('‚úÖ Camera stopped successfully');
            } else {
                console.log('‚ö†Ô∏è No camera to stop');
            }
        }

        // Legacy getUserMedia fallback for older Safari versions
        function startCameraLegacy() {
            console.log('üìπ Using legacy getUserMedia for older browsers');

            const video = document.getElementById('arVideo');
            const canvas = document.getElementById('arCanvas');
            const button = document.getElementById('startCameraBtn');
            const cameraArea = document.getElementById('arCameraArea');

            const constraints = {
                video: true,
                audio: false
            };

            const getUserMedia = navigator.getUserMedia ||
                               navigator.webkitGetUserMedia ||
                               navigator.mozGetUserMedia ||
                               navigator.msGetUserMedia;

            getUserMedia.call(navigator, constraints,
                function(stream) {
                    console.log('‚úÖ Legacy camera stream obtained');

                    // Convert stream to URL for older browsers
                    const videoURL = window.URL.createObjectURL(stream);
                    video.src = videoURL;
                    video.classList.remove('hidden');
                    button.style.display = 'none';

                    video.onloadedmetadata = function() {
                        video.play();
                        canvas.width = video.videoWidth || 640;
                        canvas.height = video.videoHeight || 480;
                        currentCamera = stream;
                        renderAROverlay();
                    };

                    // Add stop camera button
                    const existingStopBtn = cameraArea.querySelector('.stop-camera-btn');
                    if (!existingStopBtn) {
                        const stopBtn = document.createElement('button');
                        stopBtn.innerHTML = '‚ùå Stop Camera';
                        stopBtn.className = 'stop-camera-btn absolute top-4 right-4 bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded-lg z-10';
                        stopBtn.onclick = stopCamera;
                        cameraArea.appendChild(stopBtn);
                    }
                },
                function(error) {
                    console.error('‚ùå Legacy camera error:', error);
                    alert('Camera access failed. Please check your browser settings and try again.');
                }
            );
        }

        // Enhanced AR variables for pose detection
        let poseLandmarker = null;
        let currentPose = null;
        let cachedClothingImages = {};
        let frameSkipCounter = 0;
        let selectedClothingItem = null;
        let itemTransforms = {};

        // Initialize MediaPipe pose detection
        async function initializePoseDetection() {
            try {
                console.log('üß† Loading MediaPipe pose detection...');

                const { PoseLandmarker, FilesetResolver } = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8');

                const vision = await FilesetResolver.forVisionTasks(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
                );

                poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    numPoses: 1,
                    minPoseDetectionConfidence: 0.5,
                    minPosePresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                console.log('‚úÖ MediaPipe pose detection ready');
                return true;
            } catch (error) {
                console.error('‚ùå Failed to initialize pose detection:', error);
                return false;
            }
        }

        // Convert MediaPipe landmarks to our pose format
        function convertMediaPipePose(landmarks, video) {
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;

            const landmarkMap = {
                nose: 0,
                left_shoulder: 11, right_shoulder: 12,
                left_elbow: 13, right_elbow: 14,
                left_wrist: 15, right_wrist: 16,
                left_hip: 23, right_hip: 24,
                left_knee: 25, right_knee: 26,
                left_ankle: 27, right_ankle: 28
            };

            const keypoints = [];
            for (const [name, index] of Object.entries(landmarkMap)) {
                if (landmarks[index]) {
                    const landmark = landmarks[index];
                    keypoints.push({
                        name: name,
                        x: landmark.x * videoWidth,
                        y: landmark.y * videoHeight,
                        score: landmark.visibility || 0.8
                    });
                }
            }

            return { keypoints };
        }

        // Create clothing path for different categories based on pose keypoints
        function createClothingPathForCategory(category, pose, scale) {
            const keypoints = pose.keypoints;
            const leftShoulder = keypoints.find(kp => kp.name === 'left_shoulder');
            const rightShoulder = keypoints.find(kp => kp.name === 'right_shoulder');
            const leftHip = keypoints.find(kp => kp.name === 'left_hip');
            const rightHip = keypoints.find(kp => kp.name === 'right_hip');
            const leftElbow = keypoints.find(kp => kp.name === 'left_elbow');
            const rightElbow = keypoints.find(kp => kp.name === 'right_elbow');

            if (!leftShoulder || !rightShoulder || !leftHip || !rightHip) return null;

            // Get transforms for this specific item
            const itemId = selectedClothingItem || category;
            const transforms = itemTransforms[itemId] || { scale: 1, offsetY: 0, width: 1.6 };

            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
            const centerX = (leftShoulder.x + rightShoulder.x) / 2;

            const categoryType = getCategoryType(category.toLowerCase());

            switch (categoryType) {
                case 'tops':
                    return createTopClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms);
                case 'bottoms':
                    return createBottomClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, scale, transforms);
                case 'dresses':
                    return createDressClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms);
                case 'outerwear':
                    return createOuterwearClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms);
                case 'shoes':
                    const leftAnkle = keypoints.find(kp => kp.name === 'left_ankle');
                    const rightAnkle = keypoints.find(kp => kp.name === 'right_ankle');
                    return createShoesClothingPath(leftHip, rightHip, leftAnkle, rightAnkle, scale, transforms);
                default:
                    return null;
            }
        }

        // Map category names to types
        function getCategoryType(category) {
            if (category.includes('shirt') || category.includes('top') || category.includes('sweater') || category.includes('tank')) return 'tops';
            if (category.includes('pants') || category.includes('shorts') || category.includes('skirt')) return 'bottoms';
            if (category.includes('dress')) return 'dresses';
            if (category.includes('coat') || category.includes('jacket')) return 'outerwear';
            if (category.includes('shoes') || category.includes('boot')) return 'shoes';
            return 'tops'; // default
        }

        // Enhanced AR rendering with MediaPipe pose detection and body mapping
        async function renderAROverlay() {
            const video = document.getElementById('arVideo');
            const canvas = document.getElementById('arCanvas');
            const ctx = canvas.getContext('2d');

            if (!currentCamera) return;

            // Frame skipping for performance (every 2nd frame)
            frameSkipCounter++;
            if (frameSkipCounter % 2 !== 0) {
                requestAnimationFrame(renderAROverlay);
                return;
            }

            // Set canvas size to match video
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;

            // Clear canvas and draw video frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // AR overlay with enhanced body mapping
            const outfitItems = Object.values(selectedOutfit).filter(Boolean);

            // Get AR settings
            const opacitySlider = document.getElementById('opacitySlider');
            const scaleSlider = document.getElementById('scaleSlider');
            const opacity = (opacitySlider?.value || 70) / 100;
            const scale = (scaleSlider?.value || 100) / 100;

            if (outfitItems.length > 0 && poseLandmarker) {
                try {
                    // Detect pose using MediaPipe
                    const currentTime = performance.now();
                    const poseLandmarkResult = poseLandmarker.detectForVideo(video, currentTime);

                    if (poseLandmarkResult.landmarks && poseLandmarkResult.landmarks.length > 0) {
                        // Convert MediaPipe landmarks to our format
                        currentPose = convertMediaPipePose(poseLandmarkResult.landmarks[0], video);

                        // Render each clothing item with body-mapped placement
                        await renderOutfitItemsOnBody(ctx, outfitItems, currentPose, opacity, scale);

                        // Draw pose skeleton if debug mode enabled
                        if (window.debugMode) {
                            drawPoseSkeleton(ctx, poseLandmarkResult.landmarks[0], video);
                        }

                        // Show person detected status
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.8)';
                        ctx.font = '12px Inter';
                        ctx.textAlign = 'left';
                        ctx.fillText('‚úì Person detected - Enhanced AR active', 15, 25);

                    } else {
                        // Fallback to simple positioning if no pose detected
                        await renderOutfitItemsSimple(ctx, outfitItems, opacity, scale);

                        // Show "no person detected" message
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
                        ctx.font = '12px Inter';
                        ctx.textAlign = 'left';
                        ctx.fillText('‚ö†Ô∏è Move into camera view for better fit', 15, 25);
                    }
                } catch (error) {
                    console.warn('Pose detection error:', error);
                    // Fallback to simple rendering
                    await renderOutfitItemsSimple(ctx, outfitItems, opacity, scale);
                }
            } else if (outfitItems.length > 0) {
                // Simple body center detection using skin tone analysis
                const bodyCenter = detectBodyCenter(ctx, canvas);
                const centerX = bodyCenter.x;
                const centerY = bodyCenter.y;

                // Define body regions for clothing placement
                const regions = {
                    'tops': { x: centerX, y: centerY - 60, width: 120 * scale, height: 100 * scale },
                    'bottoms': { x: centerX, y: centerY + 40, width: 100 * scale, height: 120 * scale },
                    'dresses': { x: centerX, y: centerY - 20, width: 110 * scale, height: 160 * scale },
                    'outerwear': { x: centerX, y: centerY - 80, width: 140 * scale, height: 120 * scale },
                    'shoes': { x: centerX, y: centerY + 130, width: 80 * scale, height: 50 * scale },
                    'accessories': { x: centerX, y: centerY - 100, width: 60 * scale, height: 40 * scale }
                };

                // Render each clothing item
                Object.entries(selectedOutfit).forEach(([category, item]) => {
                    if (!item || !regions[category]) return;

                    const region = regions[category];

                    // Draw actual clothing image
                    ctx.save();
                    ctx.globalAlpha = opacity;

                    // Create image element and draw it
                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    // Draw the image immediately if it's already loaded, or queue it for loading
                    if (item.imageElement && item.imageElement.complete) {
                        // Image is already loaded
                        ctx.drawImage(
                            item.imageElement,
                            region.x - region.width / 2,
                            region.y - region.height / 2,
                            region.width,
                            region.height
                        );
                    } else {
                        // Load the image
                        img.onload = () => {
                            ctx.save();
                            ctx.globalAlpha = opacity;
                            ctx.drawImage(
                                img,
                                region.x - region.width / 2,
                                region.y - region.height / 2,
                                region.width,
                                region.height
                            );
                            ctx.restore();
                        };
                        img.src = item.image;

                        // Store for future use
                        item.imageElement = img;

                        // Draw placeholder while loading
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.fillRect(
                            region.x - region.width / 2,
                            region.y - region.height / 2,
                            region.width,
                            region.height
                        );
                        ctx.strokeRect(
                            region.x - region.width / 2,
                            region.y - region.height / 2,
                            region.width,
                            region.height
                        );

                        // Loading text
                        ctx.fillStyle = 'white';
                        ctx.font = '12px Inter';
                        ctx.textAlign = 'center';
                        ctx.fillText(
                            'Loading...',
                            region.x,
                            region.y
                        );
                    }

                    // Add clothing label overlay
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    const labelWidth = Math.max(80, item.category.length * 8);
                    const labelHeight = 18;
                    ctx.fillRect(
                        region.x - labelWidth / 2,
                        region.y + region.height / 2 - labelHeight,
                        labelWidth,
                        labelHeight
                    );

                    ctx.fillStyle = 'white';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(
                        item.category.charAt(0).toUpperCase() + item.category.slice(1),
                        region.x,
                        region.y + region.height / 2 - 4
                    );

                    ctx.restore();
                });

                // Show body detection point if enabled
                const showBodyDetection = document.getElementById('showBodyDetection')?.checked;
                if (showBodyDetection) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = '10px Inter';
                    ctx.textAlign = 'left';
                    ctx.fillText('Body Center', centerX + 15, centerY - 5);
                }

                // Draw AR status
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(10, 10, 340, 70);

                ctx.fillStyle = 'white';
                ctx.font = '14px Inter';
                ctx.textAlign = 'left';
                ctx.fillText('üé≠ AR Try-On Active', 15, 28);
                ctx.font = '11px Inter';
                ctx.fillText(`${outfitItems.length} items ‚Ä¢ ${Math.round(opacity * 100)}% opacity ‚Ä¢ ${Math.round(scale * 100)}% scale`, 15, 45);
                ctx.fillText(`Body Center: ${Math.round(centerX)}, ${Math.round(centerY)}`, 15, 60);

            } else {
                // No outfit selected
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(canvas.width / 2 - 100, canvas.height / 2 - 30, 200, 60);

                ctx.fillStyle = 'black';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.fillText('No outfit selected', canvas.width / 2, canvas.height / 2 - 5);
                ctx.font = '12px Inter';
                ctx.fillText('Go to "Pick Outfit" first', canvas.width / 2, canvas.height / 2 + 15);
            }

            // Continue rendering loop
            if (currentCamera) {
                requestAnimationFrame(renderAROverlay);
            }
        }

        // Render clothing items mapped to body pose
        async function renderOutfitItemsOnBody(ctx, outfitItems, pose, opacity, scale) {
            // Get essential pose keypoints
            const leftShoulder = pose.keypoints.find(kp => kp.name === 'left_shoulder');
            const rightShoulder = pose.keypoints.find(kp => kp.name === 'right_shoulder');
            const leftHip = pose.keypoints.find(kp => kp.name === 'left_hip');
            const rightHip = pose.keypoints.find(kp => kp.name === 'right_hip');

            if (!leftShoulder || !rightShoulder || !leftHip || !rightHip) {
                await renderOutfitItemsSimple(ctx, outfitItems, opacity, scale);
                return;
            }

            // Process each clothing item
            for (const [category, item] of Object.entries(selectedOutfit)) {
                if (!item) continue;

                const clothingPath = createClothingPathForCategory(item.category, pose, scale);
                if (clothingPath) {
                    await renderClothingOnPath(ctx, item, clothingPath, opacity);
                }
            }
        }

        // Create clothing paths for different categories
        function createTopClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms) {
            const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x);
            const centerX = (leftShoulder.x + rightShoulder.x) / 2;
            const centerY = (leftShoulder.y + rightShoulder.y) / 2 + transforms.offsetY;

            const widthMultiplier = transforms.width;
            const clothingWidth = shoulderWidth * scale * widthMultiplier;

            const leftShoulderClothing = {
                x: centerX - clothingWidth / 2,
                y: centerY - 30
            };
            const rightShoulderClothing = {
                x: centerX + clothingWidth / 2,
                y: centerY - 30
            };

            const hipCenterY = (leftHip.y + rightHip.y) / 2 + transforms.offsetY - 20;
            const hipWidth = Math.abs(rightHip.x - leftHip.x) * scale * 1.4;

            const leftHipClothing = {
                x: centerX - hipWidth / 2,
                y: hipCenterY
            };
            const rightHipClothing = {
                x: centerX + hipWidth / 2,
                y: hipCenterY
            };

            return [leftShoulderClothing, rightShoulderClothing, rightHipClothing, leftHipClothing];
        }

        function createBottomClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, scale, transforms) {
            const centerX = (leftHip.x + rightHip.x) / 2;
            const hipWidth = Math.abs(rightHip.x - leftHip.x);

            const clothingWidth = hipWidth * scale * transforms.width;
            const startY = (leftHip.y + rightHip.y) / 2 + transforms.offsetY;

            return [
                { x: centerX - clothingWidth / 2, y: startY },
                { x: centerX + clothingWidth / 2, y: startY },
                { x: centerX + clothingWidth * 0.4, y: startY + 120 * scale },
                { x: centerX - clothingWidth * 0.4, y: startY + 120 * scale }
            ];
        }

        function createDressClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms) {
            // Combine top and dress logic
            const topPath = createTopClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms);

            const centerX = (leftHip.x + rightHip.x) / 2;
            const hipWidth = Math.abs(rightHip.x - leftHip.x);
            const clothingWidth = hipWidth * scale * transforms.width;
            const extendY = (leftHip.y + rightHip.y) / 2 + 100 + transforms.offsetY;

            // Extend the dress lower
            return [
                topPath[0], // left shoulder
                topPath[1], // right shoulder
                { x: centerX + clothingWidth * 0.6, y: extendY }, // right hem
                { x: centerX - clothingWidth * 0.6, y: extendY }  // left hem
            ];
        }

        function createOuterwearClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, transforms) {
            // Make outerwear larger than regular tops
            const modifiedTransforms = { ...transforms, width: transforms.width * 1.2 };
            return createTopClothingPath(leftShoulder, rightShoulder, leftHip, rightHip, leftElbow, rightElbow, scale, modifiedTransforms);
        }

        function createShoesClothingPath(leftHip, rightHip, leftAnkle, rightAnkle, scale, transforms) {
            let centerX = (leftHip.x + rightHip.x) / 2;
            let baseY = leftHip.y + 200; // Default position

            // Use ankle positions if available
            if (leftAnkle && rightAnkle) {
                centerX = (leftAnkle.x + rightAnkle.x) / 2;
                baseY = (leftAnkle.y + rightAnkle.y) / 2;
            }

            const shoeWidth = 120 * scale * transforms.width;
            const shoeHeight = 40 * scale;

            return [
                { x: centerX - shoeWidth / 2, y: baseY + transforms.offsetY },
                { x: centerX + shoeWidth / 2, y: baseY + transforms.offsetY },
                { x: centerX + shoeWidth / 2, y: baseY + shoeHeight + transforms.offsetY },
                { x: centerX - shoeWidth / 2, y: baseY + shoeHeight + transforms.offsetY }
            ];
        }

        // Render clothing texture mapped to path
        async function renderClothingOnPath(ctx, item, clothingPath, opacity) {
            // Use cached image if available
            const cacheKey = item.id || item.category;
            if (!cachedClothingImages[cacheKey] || cachedClothingImages[cacheKey].src !== item.image) {
                cachedClothingImages[cacheKey] = new Image();
                cachedClothingImages[cacheKey].src = item.image;
            }

            const img = cachedClothingImages[cacheKey];
            if (!img.complete) return; // Skip if not loaded yet

            ctx.save();
            ctx.globalAlpha = opacity;

            // Create clipping path
            ctx.beginPath();
            clothingPath.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.closePath();
            ctx.clip();

            // Calculate bounds for texture mapping
            const bounds = calculatePathBounds(clothingPath);

            // Apply background removal effect for better integration
            if (item.backgroundRemoved) {
                ctx.filter = 'brightness(1.1) contrast(1.1)';
            }

            // Draw texture within clipped path
            ctx.drawImage(img, bounds.x - 15, bounds.y - 10, bounds.width + 30, bounds.height + 20);

            ctx.restore();

            // Draw selection indicator if this item is selected
            if (selectedClothingItem === cacheKey) {
                drawSelectionIndicator(ctx, clothingPath);
            }
        }

        // Calculate bounds of clothing path
        function calculatePathBounds(path) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            path.forEach(point => {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            });

            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }

        // Draw selection indicator around selected clothing item
        function drawSelectionIndicator(ctx, clothingPath) {
            ctx.save();
            ctx.strokeStyle = '#00FFFF';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);

            ctx.beginPath();
            clothingPath.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.closePath();
            ctx.stroke();

            ctx.restore();
        }

        // Simple fallback rendering without pose detection
        async function renderOutfitItemsSimple(ctx, outfitItems, opacity, scale) {
            // Use the existing simple rendering logic as fallback
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;

            // Define simple regions (fallback)
            const regions = {
                'tops': { x: centerX, y: centerY - 60, width: 120 * scale, height: 100 * scale },
                'bottoms': { x: centerX, y: centerY + 40, width: 100 * scale, height: 120 * scale },
                'dresses': { x: centerX, y: centerY - 20, width: 110 * scale, height: 160 * scale },
                'outerwear': { x: centerX, y: centerY - 80, width: 140 * scale, height: 120 * scale },
                'shoes': { x: centerX, y: centerY + 130, width: 80 * scale, height: 50 * scale }
            };

            // Render using simple rectangles
            for (const [category, item] of Object.entries(selectedOutfit)) {
                if (!item) continue;

                const categoryType = getCategoryType(item.category);
                const region = regions[categoryType];
                if (!region) continue;

                const cacheKey = item.id || item.category;
                if (!cachedClothingImages[cacheKey]) {
                    cachedClothingImages[cacheKey] = new Image();
                    cachedClothingImages[cacheKey].src = item.image;
                }

                const img = cachedClothingImages[cacheKey];
                if (img.complete) {
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    ctx.drawImage(img, region.x - region.width / 2, region.y - region.height / 2, region.width, region.height);
                    ctx.restore();
                }
            }
        }

        // Draw pose skeleton for debugging
        function drawPoseSkeleton(ctx, landmarks, video) {
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;

            ctx.strokeStyle = '#00FF00';
            ctx.fillStyle = '#00FF00';
            ctx.lineWidth = 2;

            // Draw key landmarks
            const keyLandmarks = [11, 12, 23, 24, 13, 14, 15, 16]; // shoulders, hips, elbows, wrists
            keyLandmarks.forEach(index => {
                if (landmarks[index] && landmarks[index].visibility > 0.5) {
                    const x = landmarks[index].x * videoWidth;
                    const y = landmarks[index].y * videoHeight;

                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // Draw connections
            const connections = [
                [11, 12], // shoulders
                [11, 23], [12, 24], // shoulder to hip
                [23, 24], // hips
                [11, 13], [13, 15], // left arm
                [12, 14], [14, 16]  // right arm
            ];

            connections.forEach(([from, to]) => {
                const fromLandmark = landmarks[from];
                const toLandmark = landmarks[to];

                if (fromLandmark && toLandmark && fromLandmark.visibility > 0.5 && toLandmark.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.moveTo(fromLandmark.x * videoWidth, fromLandmark.y * videoHeight);
                    ctx.lineTo(toLandmark.x * videoWidth, toLandmark.y * videoHeight);
                    ctx.stroke();
                }
            });
        }

        function detectBodyCenter(ctx, canvas) {
            // Simple fallback body center detection
            // Returns center of canvas as a reasonable default
            return {
                x: canvas.width / 2,
                y: canvas.height / 2
            };
        }

        function updateARSetting(setting, value) {
            // Update slider display
            const slider = document.getElementById(setting + 'Slider');
            const display = slider.nextElementSibling;
            display.textContent = value + (setting === 'opacity' ? '%' : '%');

            // Apply AR settings (placeholder)
            console.log(`AR ${setting} set to ${value}`);
        }

        // ======================================
        // AR TRY-ON INTEGRATION
        // ======================================

        // AR Variables
        let arPoseLandmarker = null;
        let arObjectDetector = null;
        let arCameraStream = null;
        let arProcessedClothing = null;
        let arDetectionActive = false;
        let arClothingVisible = true;
        let arDebugMode = false;
        let arFrameSkipCounter = 0;
        let arFrameCount = 0;
        let arLastTime = performance.now();
        let arClothingTransform = { scale: 1, offsetY: 0, width: 1.6 };

        // Initialize AR models
        async function initializeARModels() {
            try {
                console.log('üß† Loading AR MediaPipe models...');
                const { PoseLandmarker, ObjectDetector, FilesetResolver } = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8');

                updateARStatus('arPoseStatus', 'loading', 'Loading MediaPipe...');
                const vision = await FilesetResolver.forVisionTasks(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
                );

                updateARStatus('arPoseStatus', 'loading', 'Loading pose landmarker...');
                arPoseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    numPoses: 1,
                    minPoseDetectionConfidence: 0.5,
                    minPosePresenceConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                updateARStatus('arPoseStatus', 'ready', 'Pose Detection: Ready');

                updateARStatus('arSegmentStatus', 'loading', 'Loading object detector...');
                arObjectDetector = await ObjectDetector.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    maxResults: 10,
                    scoreThreshold: 0.3
                });
                updateARStatus('arSegmentStatus', 'ready', 'Object Detection: Ready');

                console.log('‚úÖ AR MediaPipe models loaded successfully');
            } catch (error) {
                console.error('‚ùå Failed to load AR MediaPipe models:', error);
                updateARStatus('arPoseStatus', 'error', 'Pose Detection: Failed');
                updateARStatus('arSegmentStatus', 'error', 'Object Detection: Failed');
            }
        }

        function updateARStatus(elementId, status, message) {
            const element = document.getElementById(elementId);
            if (!element) return;
            const dot = element.querySelector('.arStatusDot');
            const text = element.querySelector('span:last-child');
            if (dot) {
                dot.style.backgroundColor = status === 'loading' ? '#fbbf24' : status === 'ready' ? '#10b981' : '#ef4444';
                dot.style.animation = status === 'loading' ? 'pulse 1.5s infinite' : 'none';
            }
            if (text) text.textContent = message;
        }

        async function startARTryOn() {
            try {
                console.log('üöÄ Starting AR Try-On...');
                if (Object.keys(selectedOutfit).length === 0) {
                    alert('Please select some clothing items first from your closet or "Pick Outfit" tab!');
                    return;
                }
                if (!arPoseLandmarker) await initializeARModels();
                await processOutfitForAR();
                await startARCamera();
                document.getElementById('arFullscreen').classList.remove('hidden');
                document.getElementById('arControlsPanel').style.display = 'block';
                updateAROutfitDisplay();
                console.log('‚úÖ AR Try-On started');
            } catch (error) {
                console.error('‚ùå AR Try-On failed to start:', error);
                alert('Failed to start AR Try-On: ' + error.message);
            }
        }

        async function processOutfitForAR() {
            const outfitItems = Object.values(selectedOutfit).filter(Boolean);
            if (outfitItems.length === 0) return;

            // Process all outfit items for AR
            arProcessedClothing = [];

            for (const item of outfitItems) {
                // Remove background from clothing image
                const processedImageData = await removeClothingBackgroundAR(item.image);

                const processedItem = {
                    image: processedImageData,
                    originalImage: item.image,
                    category: item.category,
                    mesh: await generateClothingMeshForAR(processedImageData),
                    id: item.id || Date.now()
                };

                arProcessedClothing.push(processedItem);
            }

            console.log('‚úÖ Outfit processed for AR:', arProcessedClothing.length, 'items');
        }

        // Background removal for AR
        async function removeClothingBackgroundAR(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;

                    ctx.drawImage(img, 0, 0);

                    // Apply background removal
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const width = canvas.width;
                    const height = canvas.height;

                    // Sample edge pixels for background detection
                    const edgePixels = [];
                    for (let x = 0; x < width; x += Math.max(1, Math.floor(width / 20))) {
                        edgePixels.push({ x, y: 0 });
                        edgePixels.push({ x, y: height - 1 });
                    }
                    for (let y = 0; y < height; y += Math.max(1, Math.floor(height / 20))) {
                        edgePixels.push({ x: 0, y });
                        edgePixels.push({ x: width - 1, y });
                    }

                    // Get background color samples
                    const backgroundColors = [];
                    edgePixels.forEach(pixel => {
                        const index = (pixel.y * width + pixel.x) * 4;
                        backgroundColors.push({
                            r: data[index],
                            g: data[index + 1],
                            b: data[index + 2]
                        });
                    });

                    // Remove background pixels
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];

                        // Check if pixel matches background
                        for (const bg of backgroundColors) {
                            const colorDiff = Math.abs(r - bg.r) + Math.abs(g - bg.g) + Math.abs(b - bg.b);
                            const brightness = (r + g + b) / 3;
                            const bgBrightness = (bg.r + bg.g + bg.b) / 3;
                            const brightnessDiff = Math.abs(brightness - bgBrightness);

                            let threshold = 80;
                            if (brightness < 50 || brightness > 200) threshold = 120;

                            if (colorDiff < threshold && brightnessDiff < 40) {
                                data[i + 3] = 0; // Make transparent
                                break;
                            }
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.src = imageUrl;
            });
        }

        async function generateClothingMeshForAR(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const mesh = { vertices: [], faces: [], image: img, width: img.width, height: img.height };
                    const w = 1.0, h = (img.height / img.width);
                    mesh.vertices = [-w/2, -h/2, 0, w/2, -h/2, 0, w/2, h/2, 0, -w/2, h/2, 0];
                    mesh.faces = [0, 1, 2, 0, 2, 3];
                    resolve(mesh);
                };
                img.src = imageUrl;
            });
        }

        async function startARCamera() {
            try {
                console.log('üìπ Starting AR camera...');
                const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' }, audio: false };
                arCameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                const video = document.getElementById('arCameraVideo');
                video.srcObject = arCameraStream;
                video.onloadedmetadata = () => {
                    video.play();
                    setupARCanvas();
                    startARDetectionLoop();
                };
                console.log('‚úÖ AR Camera started');
            } catch (error) {
                console.error('‚ùå AR Camera error:', error);
                throw error;
            }
        }

        function setupARCanvas() {
            const video = document.getElementById('arCameraVideo');
            const canvas = document.getElementById('arOverlayCanvas');
            canvas.width = video.videoWidth || 1280;
            canvas.height = video.videoHeight || 720;
            console.log('üìê AR Canvas setup:', canvas.width, 'x', canvas.height);
        }

        function startARDetectionLoop() {
            if (!arDetectionActive) {
                arDetectionActive = true;
                requestAnimationFrame(arDetectionFrame);
            }
        }

        async function arDetectionFrame() {
            if (!arDetectionActive || !arCameraStream) return;
            const video = document.getElementById('arCameraVideo');
            const canvas = document.getElementById('arOverlayCanvas');
            const ctx = canvas.getContext('2d');
            arFrameSkipCounter++;
            if (arFrameSkipCounter % 3 !== 0) {
                requestAnimationFrame(arDetectionFrame);
                return;
            }
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (arPoseLandmarker && video.readyState >= 2) {
                    const currentTime = performance.now();
                    const results = arPoseLandmarker.detectForVideo(video, currentTime);
                    if (results.landmarks && results.landmarks.length > 0) {
                        const landmarks = results.landmarks[0];
                        if (arDebugMode) drawARPoseSkeleton(ctx, landmarks, canvas.width, canvas.height);
                        if (arProcessedClothing && arProcessedClothing.length > 0 && arClothingVisible) {
                            await drawARClothingItems(ctx, landmarks, canvas.width, canvas.height);
                        }
                        document.getElementById('arPersonDetected').textContent = '‚úÖ';
                        document.getElementById('arBodyParts').textContent = landmarks.length;
                    } else {
                        document.getElementById('arPersonDetected').textContent = '‚ùå';
                        document.getElementById('arBodyParts').textContent = '0';
                    }
                }
                document.getElementById('arClothingActive').textContent = (arProcessedClothing && arProcessedClothing.length > 0 && arClothingVisible) ? '‚úÖ' : '‚ùå';
                arFrameCount++;
            } catch (error) {
                console.error('‚ùå AR Detection error:', error);
            }
            requestAnimationFrame(arDetectionFrame);
        }

        async function drawARClothingItems(ctx, landmarks, width, height) {
            if (!arProcessedClothing || !landmarks || arProcessedClothing.length === 0) {
                return;
            }

            // Draw each clothing item in its appropriate location
            for (const clothingItem of arProcessedClothing) {
                await drawSingleARClothingItem(ctx, clothingItem, landmarks, width, height);
            }
        }

        async function drawSingleARClothingItem(ctx, clothingItem, landmarks, width, height) {
            const categoryLower = clothingItem.category.toLowerCase();

            // Simple direct drawing - just overlay the image on body position
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];

            if (!leftShoulder || !rightShoulder) return;

            const userScale = arClothingTransform.scale;
            const userOffsetY = arClothingTransform.offsetY;
            const userWidthMult = arClothingTransform.width;

            ctx.save();
            ctx.globalAlpha = 0.85;

            // Draw based on category
            if (['shirt', 'top', 'blouse', 'jacket', 'coat', 'sweater', 'hoodie'].includes(categoryLower)) {
                if (!leftHip || !rightHip) return;

                const centerX = (leftShoulder.x + rightShoulder.x) / 2 * width;
                const topY = Math.min(leftShoulder.y, rightShoulder.y) * height - 30;
                const imgWidth = Math.abs(rightShoulder.x - leftShoulder.x) * width * 1.4 * userWidthMult;
                const hipY = (leftHip.y + rightHip.y) / 2 * height;
                const imgHeight = (hipY - topY + 20) * userScale;

                ctx.drawImage(
                    clothingItem.mesh.image,
                    centerX - imgWidth / 2,
                    topY + userOffsetY,
                    imgWidth,
                    imgHeight
                );
            }
            else if (['pants', 'jeans', 'trousers', 'shorts', 'leggings'].includes(categoryLower)) {
                if (!leftHip || !rightHip || !leftAnkle || !rightAnkle) return;

                const centerX = (leftHip.x + rightHip.x) / 2 * width;
                const topY = (leftHip.y + rightHip.y) / 2 * height - 40;
                const imgWidth = Math.abs(rightHip.x - leftHip.x) * width * 1.3 * userWidthMult;
                const ankleY = (leftAnkle.y + rightAnkle.y) / 2 * height;
                const imgHeight = (ankleY - topY) * userScale;

                ctx.drawImage(
                    clothingItem.mesh.image,
                    centerX - imgWidth / 2,
                    topY + userOffsetY,
                    imgWidth,
                    imgHeight
                );
            }
            else if (['dress', 'skirt', 'jumpsuit', 'romper'].includes(categoryLower)) {
                if (!leftHip || !rightHip || !leftKnee || !rightKnee) return;

                const centerX = (leftShoulder.x + rightShoulder.x) / 2 * width;
                const topY = Math.min(leftShoulder.y, rightShoulder.y) * height - 30;
                const imgWidth = Math.abs(rightShoulder.x - leftShoulder.x) * width * 1.5 * userWidthMult;
                const kneeY = (leftKnee.y + rightKnee.y) / 2 * height;
                const imgHeight = (kneeY - topY) * userScale;

                ctx.drawImage(
                    clothingItem.mesh.image,
                    centerX - imgWidth / 2,
                    topY + userOffsetY,
                    imgWidth,
                    imgHeight
                );
            }
            else {
                // Default: draw at shoulder
                const centerX = (leftShoulder.x + rightShoulder.x) / 2 * width;
                const topY = leftShoulder.y * height;
                const imgWidth = Math.abs(rightShoulder.x - leftShoulder.x) * width * 1.5 * userWidthMult;
                const imgHeight = imgWidth * (clothingItem.mesh.image.height / clothingItem.mesh.image.width) * userScale;

                ctx.drawImage(
                    clothingItem.mesh.image,
                    centerX - imgWidth / 2,
                    topY + userOffsetY,
                    imgWidth,
                    imgHeight
                );
            }

            ctx.restore();
        }

        // Define body segments based on landmarks (like the stick figure diagram)
        function defineBodySegments(landmarks, width, height) {
            const segments = {};

            console.log('üî¨ defineBodySegments called, landmarks:', landmarks ? landmarks.length : 'null');

            if (!landmarks || landmarks.length === 0) {
                console.error('‚ùå No landmarks provided to defineBodySegments');
                return segments;
            }

            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftElbow = landmarks[13];
            const rightElbow = landmarks[14];
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            const leftEye = landmarks[2];
            const rightEye = landmarks[5];

            console.log('üë§ Key landmarks:', {
                leftShoulder: !!leftShoulder,
                rightShoulder: !!rightShoulder,
                leftHip: !!leftHip,
                rightHip: !!rightHip,
                leftWrist: !!leftWrist,
                rightWrist: !!rightWrist
            });

            // Helper to check visibility
            function isVisible(landmark, threshold = 0.3) {
                return landmark && landmark.visibility >= threshold;
            }

            // HEAD segment (circle)
            if (isVisible(nose) && isVisible(leftEye) && isVisible(rightEye)) {
                const headCenterX = (leftEye.x + rightEye.x) / 2 * width;
                const headCenterY = (leftEye.y + rightEye.y) / 2 * height - 20;
                const headRadius = Math.abs(rightEye.x - leftEye.x) * width * 1.2;

                segments.head = {
                    name: 'head',
                    center: { x: headCenterX, y: headCenterY },
                    radius: headRadius,
                    boundary: generateCircleBoundary(headCenterX, headCenterY, headRadius, 16),
                    visible: true
                };
            }

            // TORSO segment (trapezoid from shoulders to hips)
            if (isVisible(leftShoulder) && isVisible(rightShoulder) && isVisible(leftHip) && isVisible(rightHip)) {
                const shoulderExtend = Math.abs(rightShoulder.x - leftShoulder.x) * width * 0.15;
                const hipExtend = Math.abs(rightHip.x - leftHip.x) * width * 0.1;

                segments.torso = {
                    name: 'torso',
                    boundary: [
                        { x: leftShoulder.x * width - shoulderExtend, y: leftShoulder.y * height },
                        { x: rightShoulder.x * width + shoulderExtend, y: rightShoulder.y * height },
                        { x: rightHip.x * width + hipExtend, y: rightHip.y * height + 20 },
                        { x: leftHip.x * width - hipExtend, y: leftHip.y * height + 20 }
                    ],
                    visible: true
                };
            }

            // LEFT ARM segment (trapezoid from shoulder to wrist)
            if (isVisible(leftShoulder) && isVisible(leftWrist)) {
                const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x) * width * 0.12;
                const wristWidth = shoulderWidth * 0.4;

                const armAngle = Math.atan2(
                    (leftWrist.y - leftShoulder.y) * height,
                    (leftWrist.x - leftShoulder.x) * width
                );
                const perpAngle = armAngle + Math.PI / 2;

                segments.leftArm = {
                    name: 'leftArm',
                    boundary: [
                        {
                            x: leftShoulder.x * width + Math.cos(perpAngle) * shoulderWidth,
                            y: leftShoulder.y * height + Math.sin(perpAngle) * shoulderWidth
                        },
                        {
                            x: leftShoulder.x * width - Math.cos(perpAngle) * shoulderWidth,
                            y: leftShoulder.y * height - Math.sin(perpAngle) * shoulderWidth
                        },
                        {
                            x: leftWrist.x * width - Math.cos(perpAngle) * wristWidth,
                            y: leftWrist.y * height - Math.sin(perpAngle) * wristWidth
                        },
                        {
                            x: leftWrist.x * width + Math.cos(perpAngle) * wristWidth,
                            y: leftWrist.y * height + Math.sin(perpAngle) * wristWidth
                        }
                    ],
                    visible: true
                };
            }

            // RIGHT ARM segment
            if (isVisible(rightShoulder) && isVisible(rightWrist)) {
                const shoulderWidth = Math.abs(rightShoulder.x - leftShoulder.x) * width * 0.12;
                const wristWidth = shoulderWidth * 0.4;

                const armAngle = Math.atan2(
                    (rightWrist.y - rightShoulder.y) * height,
                    (rightWrist.x - rightShoulder.x) * width
                );
                const perpAngle = armAngle + Math.PI / 2;

                segments.rightArm = {
                    name: 'rightArm',
                    boundary: [
                        {
                            x: rightShoulder.x * width + Math.cos(perpAngle) * shoulderWidth,
                            y: rightShoulder.y * height + Math.sin(perpAngle) * shoulderWidth
                        },
                        {
                            x: rightShoulder.x * width - Math.cos(perpAngle) * shoulderWidth,
                            y: rightShoulder.y * height - Math.sin(perpAngle) * shoulderWidth
                        },
                        {
                            x: rightWrist.x * width - Math.cos(perpAngle) * wristWidth,
                            y: rightWrist.y * height - Math.sin(perpAngle) * wristWidth
                        },
                        {
                            x: rightWrist.x * width + Math.cos(perpAngle) * wristWidth,
                            y: rightWrist.y * height + Math.sin(perpAngle) * wristWidth
                        }
                    ],
                    visible: true
                };
            }

            // LEFT LEG segment
            if (isVisible(leftHip) && isVisible(leftAnkle)) {
                const hipWidth = Math.abs(rightHip.x - leftHip.x) * width * 0.15;
                const ankleWidth = hipWidth * 0.5;

                const legAngle = Math.atan2(
                    (leftAnkle.y - leftHip.y) * height,
                    (leftAnkle.x - leftHip.x) * width
                );
                const perpAngle = legAngle + Math.PI / 2;

                segments.leftLeg = {
                    name: 'leftLeg',
                    boundary: [
                        {
                            x: leftHip.x * width + Math.cos(perpAngle) * hipWidth,
                            y: leftHip.y * height + Math.sin(perpAngle) * hipWidth
                        },
                        {
                            x: leftHip.x * width - Math.cos(perpAngle) * hipWidth,
                            y: leftHip.y * height - Math.sin(perpAngle) * hipWidth
                        },
                        {
                            x: leftAnkle.x * width - Math.cos(perpAngle) * ankleWidth,
                            y: leftAnkle.y * height - Math.sin(perpAngle) * ankleWidth
                        },
                        {
                            x: leftAnkle.x * width + Math.cos(perpAngle) * ankleWidth,
                            y: leftAnkle.y * height + Math.sin(perpAngle) * ankleWidth
                        }
                    ],
                    visible: true
                };
            }

            // RIGHT LEG segment
            if (isVisible(rightHip) && isVisible(rightAnkle)) {
                const hipWidth = Math.abs(rightHip.x - leftHip.x) * width * 0.15;
                const ankleWidth = hipWidth * 0.5;

                const legAngle = Math.atan2(
                    (rightAnkle.y - rightHip.y) * height,
                    (rightAnkle.x - rightHip.x) * width
                );
                const perpAngle = legAngle + Math.PI / 2;

                segments.rightLeg = {
                    name: 'rightLeg',
                    boundary: [
                        {
                            x: rightHip.x * width + Math.cos(perpAngle) * hipWidth,
                            y: rightHip.y * height + Math.sin(perpAngle) * hipWidth
                        },
                        {
                            x: rightHip.x * width - Math.cos(perpAngle) * hipWidth,
                            y: rightHip.y * height - Math.sin(perpAngle) * hipWidth
                        },
                        {
                            x: rightAnkle.x * width - Math.cos(perpAngle) * ankleWidth,
                            y: rightAnkle.y * height - Math.sin(perpAngle) * ankleWidth
                        },
                        {
                            x: rightAnkle.x * width + Math.cos(perpAngle) * ankleWidth,
                            y: rightAnkle.y * height + Math.sin(perpAngle) * ankleWidth
                        }
                    ],
                    visible: true
                };
            }

            return segments;
        }

        // Helper to generate circle boundary points
        function generateCircleBoundary(centerX, centerY, radius, numPoints) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                points.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius
                });
            }
            return points;
        }

        // Get which body segments should be used for each clothing type
        function getBodySegmentsForClothing(landmarks, category, width, height) {
            console.log(`üîç getBodySegmentsForClothing called for ${category}`);
            console.log('  landmarks:', landmarks ? `${landmarks.length} points` : 'null');
            console.log('  width:', width, 'height:', height);

            const allSegments = defineBodySegments(landmarks, width, height);
            const segments = [];

            console.log('üîç All segments created:', Object.keys(allSegments));

            // Map clothing categories to body segments
            if (['shirt', 'top', 'blouse', 'jacket', 'coat', 'sweater', 'hoodie'].includes(category)) {
                // Shirts cover torso + arms
                console.log('üëï Creating shirt segments');
                if (allSegments.torso) {
                    segments.push({ ...allSegments.torso, uvRegion: { u0: 0.2, v0: 0, u1: 0.8, v1: 0.7 } });
                    console.log('  ‚úì Added torso');
                }
                if (allSegments.leftArm) {
                    segments.push({ ...allSegments.leftArm, uvRegion: { u0: 0, v0: 0.2, u1: 0.2, v1: 0.8 } });
                    console.log('  ‚úì Added leftArm');
                }
                if (allSegments.rightArm) {
                    segments.push({ ...allSegments.rightArm, uvRegion: { u0: 0.8, v0: 0.2, u1: 1, v1: 0.8 } });
                    console.log('  ‚úì Added rightArm');
                }
            }

            if (['pants', 'jeans', 'trousers', 'shorts', 'leggings'].includes(category)) {
                // Pants cover both legs
                if (allSegments.leftLeg) segments.push({ ...allSegments.leftLeg, uvRegion: { u0: 0, v0: 0, u1: 0.5, v1: 1 } });
                if (allSegments.rightLeg) segments.push({ ...allSegments.rightLeg, uvRegion: { u0: 0.5, v0: 0, u1: 1, v1: 1 } });
            }

            if (['dress', 'skirt', 'jumpsuit', 'romper'].includes(category)) {
                // Dresses cover torso + legs
                if (allSegments.torso) segments.push({ ...allSegments.torso, uvRegion: { u0: 0.2, v0: 0, u1: 0.8, v1: 0.4 } });
                if (allSegments.leftLeg) segments.push({ ...allSegments.leftLeg, uvRegion: { u0: 0.1, v0: 0.4, u1: 0.45, v1: 1 } });
                if (allSegments.rightLeg) segments.push({ ...allSegments.rightLeg, uvRegion: { u0: 0.55, v0: 0.4, u1: 0.9, v1: 1 } });
            }

            if (['hat', 'cap', 'beanie', 'helmet', 'headband'].includes(category)) {
                // Hats cover head
                if (allSegments.head) segments.push({ ...allSegments.head, uvRegion: { u0: 0.3, v0: 0, u1: 0.7, v1: 0.5 } });
            }

            if (['shoes', 'boots', 'sneakers', 'sandals', 'heels'].includes(category)) {
                // Shoes at feet - create foot segments
                const leftAnkle = landmarks[27];
                const rightAnkle = landmarks[28];

                if (leftAnkle && leftAnkle.visibility >= 0.3) {
                    const footLength = 50;
                    const footWidth = 35;
                    segments.push({
                        name: 'leftFoot',
                        boundary: [
                            { x: leftAnkle.x * width - footWidth, y: leftAnkle.y * height },
                            { x: leftAnkle.x * width + footWidth/2, y: leftAnkle.y * height },
                            { x: leftAnkle.x * width + footWidth/2, y: leftAnkle.y * height + footLength },
                            { x: leftAnkle.x * width - footWidth, y: leftAnkle.y * height + footLength }
                        ],
                        uvRegion: { u0: 0, v0: 0, u1: 0.5, v1: 1 },
                        visible: true
                    });
                }

                if (rightAnkle && rightAnkle.visibility >= 0.3) {
                    const footLength = 50;
                    const footWidth = 35;
                    segments.push({
                        name: 'rightFoot',
                        boundary: [
                            { x: rightAnkle.x * width - footWidth/2, y: rightAnkle.y * height },
                            { x: rightAnkle.x * width + footWidth, y: rightAnkle.y * height },
                            { x: rightAnkle.x * width + footWidth, y: rightAnkle.y * height + footLength },
                            { x: rightAnkle.x * width - footWidth/2, y: rightAnkle.y * height + footLength }
                        ],
                        uvRegion: { u0: 0.5, v0: 0, u1: 1, v1: 1 },
                        visible: true
                    });
                }
            }

            if (['bag', 'purse', 'handbag', 'backpack', 'accessory', 'jewelry', 'watch', 'bracelet'].includes(category)) {
                const rightWrist = landmarks[16];

                if (rightWrist && rightWrist.visibility >= 0.3) {
                    const size = 60;
                    segments.push({
                        name: 'accessory',
                        boundary: [
                            { x: rightWrist.x * width + 10, y: rightWrist.y * height - size/2 },
                            { x: rightWrist.x * width + 10 + size, y: rightWrist.y * height - size/2 },
                            { x: rightWrist.x * width + 10 + size, y: rightWrist.y * height + size/2 },
                            { x: rightWrist.x * width + 10, y: rightWrist.y * height + size/2 }
                        ],
                        uvRegion: { u0: 0.2, v0: 0.2, u1: 0.8, v1: 0.8 },
                        visible: true
                    });
                }
            }

            return segments;
        }

        // Old anchor point system (keeping for reference, but not used)
        function getClothingAnchorPoints(landmarks, category, width, height) {
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftElbow = landmarks[13];
            const rightElbow = landmarks[14];
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            const leftEye = landmarks[2];
            const rightEye = landmarks[5];
            const leftEar = landmarks[7];
            const rightEar = landmarks[8];

            // Helper function to check visibility
            function checkVisibility(threshold, ...requiredLandmarks) {
                for (const landmark of requiredLandmarks) {
                    if (!landmark || landmark.visibility < threshold) return false;
                }
                return true;
            }

            // Helper to calculate body depth/width at a point (for 3D wrapping effect)
            function calculateBodyWidth(leftLandmark, rightLandmark, depthFactor = 0.4) {
                const visibleWidth = Math.abs(rightLandmark.x - leftLandmark.x) * width;
                // Simulate 3D cylinder - add depth to account for body thickness
                const depthWidth = visibleWidth * depthFactor;
                return visibleWidth + depthWidth;
            }

            // Helper to extend points for body wrapping (simulates clothing going around sides)
            function extendForBodyWrap(centerX, leftX, rightX, wrapFactor = 1.2) {
                const halfWidth = Math.abs(rightX - leftX) / 2;
                return {
                    left: centerX - halfWidth * wrapFactor,
                    right: centerX + halfWidth * wrapFactor
                };
            }

            if (!leftShoulder || !rightShoulder) return null;

            // Define anchor points grid for different clothing types
            // Points are ordered for proper mesh triangulation

            // Upper body clothing (shirts, jackets, etc.)
            if (['shirt', 'top', 'blouse', 'jacket', 'coat', 'sweater', 'hoodie'].includes(category)) {
                if (!leftHip || !rightHip) return null;
                if (!checkVisibility(0.3, leftShoulder, rightShoulder, leftHip, rightHip)) {
                    return { visible: false };
                }

                // Calculate body measurements with 3D depth
                const shoulderWidth = calculateBodyWidth(leftShoulder, rightShoulder, 0.5);
                const chestWidth = calculateBodyWidth(leftShoulder, rightShoulder, 0.55); // Slightly wider for chest
                const waistWidth = calculateBodyWidth(leftHip, rightHip, 0.45);
                const hipWidth = calculateBodyWidth(leftHip, rightHip, 0.5);

                // Key vertical positions
                const neckY = Math.min(leftShoulder.y, rightShoulder.y) * height - 30;
                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * height;
                const chestY = shoulderY + (leftHip.y * height - shoulderY) * 0.25;
                const waistY = shoulderY + (leftHip.y * height - shoulderY) * 0.65;
                const hipY = (leftHip.y + rightHip.y) / 2 * height;
                const hemY = hipY + 20;

                // Center line
                const centerX = (leftShoulder.x + rightShoulder.x) / 2 * width;

                // Calculate wrap points for natural draping
                const neckWrap = extendForBodyWrap(centerX, leftShoulder.x * width, rightShoulder.x * width, 0.6);
                const shoulderWrap = extendForBodyWrap(centerX, leftShoulder.x * width, rightShoulder.x * width, 1.35);
                const chestWrap = extendForBodyWrap(centerX, leftShoulder.x * width, rightShoulder.x * width, 1.3);
                const waistWrap = extendForBodyWrap(centerX, leftHip.x * width, rightHip.x * width, 1.2);
                const hipWrap = extendForBodyWrap(centerX, leftHip.x * width, rightHip.x * width, 1.25);
                const hemWrap = extendForBodyWrap(centerX, leftHip.x * width, rightHip.x * width, 1.2);

                // Create a 5-column grid for better body contour following
                return {
                    points: [
                        // Neckline (row 0) - narrow at collar
                        { x: neckWrap.left, y: neckY },
                        { x: centerX - (neckWrap.right - neckWrap.left) * 0.25, y: neckY },
                        { x: centerX, y: neckY },
                        { x: centerX + (neckWrap.right - neckWrap.left) * 0.25, y: neckY },
                        { x: neckWrap.right, y: neckY },

                        // Shoulder line (row 1) - widest point
                        { x: shoulderWrap.left, y: shoulderY },
                        { x: leftShoulder.x * width - 10, y: shoulderY },
                        { x: centerX, y: shoulderY },
                        { x: rightShoulder.x * width + 10, y: shoulderY },
                        { x: shoulderWrap.right, y: shoulderY },

                        // Chest line (row 2) - slightly narrower
                        { x: chestWrap.left, y: chestY },
                        { x: centerX - (chestWrap.right - chestWrap.left) * 0.35, y: chestY },
                        { x: centerX, y: chestY },
                        { x: centerX + (chestWrap.right - chestWrap.left) * 0.35, y: chestY },
                        { x: chestWrap.right, y: chestY },

                        // Waist line (row 3) - tapers in
                        { x: waistWrap.left, y: waistY },
                        { x: centerX - (waistWrap.right - waistWrap.left) * 0.35, y: waistY },
                        { x: centerX, y: waistY },
                        { x: centerX + (waistWrap.right - waistWrap.left) * 0.35, y: waistY },
                        { x: waistWrap.right, y: waistY },

                        // Hip line (row 4) - widens slightly
                        { x: hipWrap.left, y: hipY },
                        { x: centerX - (hipWrap.right - hipWrap.left) * 0.35, y: hipY },
                        { x: centerX, y: hipY },
                        { x: centerX + (hipWrap.right - hipWrap.left) * 0.35, y: hipY },
                        { x: hipWrap.right, y: hipY },

                        // Hem line (row 5) - bottom edge
                        { x: hemWrap.left, y: hemY },
                        { x: centerX - (hemWrap.right - hemWrap.left) * 0.35, y: hemY },
                        { x: centerX, y: hemY },
                        { x: centerX + (hemWrap.right - hemWrap.left) * 0.35, y: hemY },
                        { x: hemWrap.right, y: hemY }
                    ],
                    gridWidth: 5,
                    gridHeight: 6,
                    visible: true
                };
            }

            // Lower body clothing (pants, jeans, etc.)
            if (['pants', 'jeans', 'trousers', 'shorts', 'leggings'].includes(category)) {
                if (!leftHip || !rightHip || !leftKnee || !rightKnee || !leftAnkle || !rightAnkle) return null;
                if (!checkVisibility(0.3, leftHip, rightHip, leftKnee, rightKnee, leftAnkle, rightAnkle)) {
                    return { visible: false };
                }

                // Calculate leg cylinder dimensions with proper depth
                const waistWidth = calculateBodyWidth(leftHip, rightHip, 0.5);
                const hipWidth = calculateBodyWidth(leftHip, rightHip, 0.55);
                const thighWidth = calculateBodyWidth(leftKnee, rightKnee, 0.45);
                const kneeWidth = calculateBodyWidth(leftKnee, rightKnee, 0.35);
                const calfWidth = calculateBodyWidth(leftAnkle, rightAnkle, 0.3);
                const ankleWidth = calculateBodyWidth(leftAnkle, rightAnkle, 0.25);

                // Vertical positions - pants start at waist, not hips
                const waistY = ((leftHip.y + rightHip.y) / 2) * height - 40;
                const hipY = ((leftHip.y + rightHip.y) / 2) * height;
                const midThighY = hipY + (leftKnee.y * height - hipY) * 0.5;
                const kneeY = (leftKnee.y + rightKnee.y) / 2 * height;
                const calfY = kneeY + (leftAnkle.y * height - kneeY) * 0.5;
                const ankleY = (leftAnkle.y + rightAnkle.y) / 2 * height;

                // Calculate individual leg positions (pants have two separate legs)
                const leftLegCenterX = leftKnee.x * width;
                const rightLegCenterX = rightKnee.x * width;
                const crotchX = (leftHip.x + rightHip.x) / 2 * width;

                // Waist wrapping
                const waistWrap = extendForBodyWrap(crotchX, leftHip.x * width, rightHip.x * width, 1.3);

                // Hip/thigh separation point
                const hipLeftEdge = leftHip.x * width - Math.abs(rightHip.x - leftHip.x) * width * 0.25;
                const hipRightEdge = rightHip.x * width + Math.abs(rightHip.x - leftHip.x) * width * 0.25;

                // Leg widths for cylindrical wrapping
                const leftThighWidth = Math.abs(leftKnee.x - leftHip.x) * width * 0.4;
                const rightThighWidth = Math.abs(rightKnee.x - rightHip.x) * width * 0.4;
                const leftKneeWidth = Math.abs(leftKnee.x - leftHip.x) * width * 0.35;
                const rightKneeWidth = Math.abs(rightKnee.x - rightHip.x) * width * 0.35;
                const leftAnkleWidth = Math.abs(leftAnkle.x - leftKnee.x) * width * 0.3;
                const rightAnkleWidth = Math.abs(rightAnkle.x - rightKnee.x) * width * 0.3;

                // Create separate columns for each leg
                return {
                    points: [
                        // Waistband (row 0) - continuous across
                        { x: waistWrap.left, y: waistY },
                        { x: crotchX - (waistWrap.right - waistWrap.left) * 0.25, y: waistY },
                        { x: crotchX, y: waistY },
                        { x: crotchX + (waistWrap.right - waistWrap.left) * 0.25, y: waistY },
                        { x: waistWrap.right, y: waistY },

                        // Hip level (row 1) - still connected
                        { x: hipLeftEdge, y: hipY },
                        { x: leftHip.x * width, y: hipY },
                        { x: crotchX, y: hipY + 10 }, // Slight drop at crotch
                        { x: rightHip.x * width, y: hipY },
                        { x: hipRightEdge, y: hipY },

                        // Mid-thigh (row 2) - legs separating
                        { x: leftLegCenterX - leftThighWidth, y: midThighY },
                        { x: leftLegCenterX - leftThighWidth * 0.3, y: midThighY },
                        { x: crotchX, y: midThighY + 20 }, // Crotch seam
                        { x: rightLegCenterX + rightThighWidth * 0.3, y: midThighY },
                        { x: rightLegCenterX + rightThighWidth, y: midThighY },

                        // Knee level (row 3) - legs fully separate
                        { x: leftKnee.x * width - leftKneeWidth, y: kneeY },
                        { x: leftKnee.x * width, y: kneeY },
                        { x: (leftKnee.x + rightKnee.x) / 2 * width, y: kneeY + 30 }, // Gap between legs
                        { x: rightKnee.x * width, y: kneeY },
                        { x: rightKnee.x * width + rightKneeWidth, y: kneeY },

                        // Calf level (row 4)
                        { x: leftKnee.x * width - leftKneeWidth * 0.9, y: calfY },
                        { x: leftKnee.x * width, y: calfY },
                        { x: (leftKnee.x + rightKnee.x) / 2 * width, y: calfY + 30 },
                        { x: rightKnee.x * width, y: calfY },
                        { x: rightKnee.x * width + rightKneeWidth * 0.9, y: calfY },

                        // Ankle level (row 5)
                        { x: leftAnkle.x * width - leftAnkleWidth, y: ankleY },
                        { x: leftAnkle.x * width, y: ankleY },
                        { x: (leftAnkle.x + rightAnkle.x) / 2 * width, y: ankleY + 30 },
                        { x: rightAnkle.x * width, y: ankleY },
                        { x: rightAnkle.x * width + rightAnkleWidth, y: ankleY }
                    ],
                    gridWidth: 5,
                    gridHeight: 6,
                    visible: true
                };
            }

            // Full body clothing (dresses, jumpsuits)
            if (['dress', 'skirt', 'jumpsuit', 'romper'].includes(category)) {
                if (!leftHip || !rightHip || !leftKnee || !rightKnee) return null;
                if (!checkVisibility(0.3, leftShoulder, rightShoulder, leftHip, rightHip, leftKnee, rightKnee)) {
                    return { visible: false };
                }

                // Dresses combine shirt-like top with flowing skirt
                const centerX = (leftShoulder.x + rightShoulder.x) / 2 * width;

                // Vertical sections
                const neckY = Math.min(leftShoulder.y, rightShoulder.y) * height - 30;
                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * height;
                const chestY = shoulderY + (leftHip.y * height - shoulderY) * 0.25;
                const waistY = shoulderY + (leftHip.y * height - shoulderY) * 0.65;
                const hipY = (leftHip.y + rightHip.y) / 2 * height;
                const midSkirtY = hipY + (leftKnee.y * height - hipY) * 0.5;
                const hemY = (leftKnee.y + rightKnee.y) / 2 * height;

                // Wrapping calculations
                const neckWrap = extendForBodyWrap(centerX, leftShoulder.x * width, rightShoulder.x * width, 0.5);
                const shoulderWrap = extendForBodyWrap(centerX, leftShoulder.x * width, rightShoulder.x * width, 1.3);
                const chestWrap = extendForBodyWrap(centerX, leftShoulder.x * width, rightShoulder.x * width, 1.25);
                const waistWrap = extendForBodyWrap(centerX, leftHip.x * width, rightHip.x * width, 1.15);
                const hipWrap = extendForBodyWrap(centerX, leftHip.x * width, rightHip.x * width, 1.35);
                const midSkirtWrap = extendForBodyWrap(centerX, leftKnee.x * width, rightKnee.x * width, 1.5);
                const hemWrap = extendForBodyWrap(centerX, leftKnee.x * width, rightKnee.x * width, 1.6);

                return {
                    points: [
                        // Neckline (row 0)
                        { x: neckWrap.left, y: neckY },
                        { x: centerX - (neckWrap.right - neckWrap.left) * 0.25, y: neckY },
                        { x: centerX, y: neckY },
                        { x: centerX + (neckWrap.right - neckWrap.left) * 0.25, y: neckY },
                        { x: neckWrap.right, y: neckY },

                        // Shoulders (row 1)
                        { x: shoulderWrap.left, y: shoulderY },
                        { x: leftShoulder.x * width, y: shoulderY },
                        { x: centerX, y: shoulderY },
                        { x: rightShoulder.x * width, y: shoulderY },
                        { x: shoulderWrap.right, y: shoulderY },

                        // Chest (row 2)
                        { x: chestWrap.left, y: chestY },
                        { x: centerX - (chestWrap.right - chestWrap.left) * 0.35, y: chestY },
                        { x: centerX, y: chestY },
                        { x: centerX + (chestWrap.right - chestWrap.left) * 0.35, y: chestY },
                        { x: chestWrap.right, y: chestY },

                        // Waist (row 3) - fitted
                        { x: waistWrap.left, y: waistY },
                        { x: centerX - (waistWrap.right - waistWrap.left) * 0.35, y: waistY },
                        { x: centerX, y: waistY },
                        { x: centerX + (waistWrap.right - waistWrap.left) * 0.35, y: waistY },
                        { x: waistWrap.right, y: waistY },

                        // Hips (row 4) - flares out
                        { x: hipWrap.left, y: hipY },
                        { x: centerX - (hipWrap.right - hipWrap.left) * 0.35, y: hipY },
                        { x: centerX, y: hipY },
                        { x: centerX + (hipWrap.right - hipWrap.left) * 0.35, y: hipY },
                        { x: hipWrap.right, y: hipY },

                        // Mid-skirt (row 5) - continues flowing
                        { x: midSkirtWrap.left, y: midSkirtY },
                        { x: centerX - (midSkirtWrap.right - midSkirtWrap.left) * 0.35, y: midSkirtY },
                        { x: centerX, y: midSkirtY },
                        { x: centerX + (midSkirtWrap.right - midSkirtWrap.left) * 0.35, y: midSkirtY },
                        { x: midSkirtWrap.right, y: midSkirtY },

                        // Hem (row 6) - widest
                        { x: hemWrap.left, y: hemY },
                        { x: centerX - (hemWrap.right - hemWrap.left) * 0.35, y: hemY },
                        { x: centerX, y: hemY },
                        { x: centerX + (hemWrap.right - hemWrap.left) * 0.35, y: hemY },
                        { x: hemWrap.right, y: hemY }
                    ],
                    gridWidth: 5,
                    gridHeight: 7,
                    visible: true
                };
            }

            // Footwear - each shoe separate
            if (['shoes', 'boots', 'sneakers', 'sandals', 'heels'].includes(category)) {
                if (!leftAnkle || !rightAnkle) return null;
                if (!checkVisibility(0.3, leftAnkle, rightAnkle)) {
                    return { visible: false };
                }

                // Shoes wrap around feet with proper depth
                const footLength = Math.abs(rightAnkle.x - leftAnkle.x) * width * 0.25;
                const footWidth = footLength * 0.6;

                // Left shoe
                const leftShoeX = leftAnkle.x * width;
                const leftShoeY = leftAnkle.y * height;

                // Right shoe
                const rightShoeX = rightAnkle.x * width;
                const rightShoeY = rightAnkle.y * height;

                return {
                    points: [
                        // Left shoe - top row
                        { x: leftShoeX - footWidth, y: leftShoeY },
                        { x: leftShoeX, y: leftShoeY },
                        { x: leftShoeX + footLength * 0.3, y: leftShoeY },
                        // Left shoe - bottom row (toe area projects forward)
                        { x: leftShoeX - footWidth, y: leftShoeY + 60 },
                        { x: leftShoeX, y: leftShoeY + 60 },
                        { x: leftShoeX + footLength, y: leftShoeY + 50 },

                        // Right shoe - top row
                        { x: rightShoeX - footLength * 0.3, y: rightShoeY },
                        { x: rightShoeX, y: rightShoeY },
                        { x: rightShoeX + footWidth, y: rightShoeY },
                        // Right shoe - bottom row
                        { x: rightShoeX - footLength, y: rightShoeY + 50 },
                        { x: rightShoeX, y: rightShoeY + 60 },
                        { x: rightShoeX + footWidth, y: rightShoeY + 60 }
                    ],
                    gridWidth: 3,
                    gridHeight: 4,
                    visible: true
                };
            }

            // Accessories (bags, jewelry, etc.) - attach to hand/wrist
            if (['bag', 'purse', 'handbag', 'backpack', 'accessory', 'jewelry', 'watch', 'bracelet'].includes(category)) {

                // Backpacks attach to shoulders
                if (['backpack'].includes(category)) {
                    if (!checkVisibility(0.3, leftShoulder, rightShoulder)) {
                        return { visible: false };
                    }
                    const shoulderSpread = Math.abs(rightShoulder.x - leftShoulder.x) * width * 0.15;
                    return {
                        points: [
                            { x: leftShoulder.x * width - shoulderSpread, y: leftShoulder.y * height },
                            { x: rightShoulder.x * width + shoulderSpread, y: rightShoulder.y * height },
                            { x: leftShoulder.x * width - shoulderSpread, y: leftShoulder.y * height + 120 },
                            { x: rightShoulder.x * width + shoulderSpread, y: rightShoulder.y * height + 120 }
                        ],
                        gridWidth: 2,
                        gridHeight: 2,
                        visible: true
                    };
                }

                // Handbags/purses attach to hand
                if (leftWrist && rightWrist) {
                    if (!checkVisibility(0.3, rightWrist)) {
                        return { visible: false };
                    }
                    // Use right wrist (dominant hand)
                    const wristX = rightWrist.x * width;
                    const wristY = rightWrist.y * height;
                    const size = 80;

                    return {
                        points: [
                            { x: wristX + 10, y: wristY - size * 0.3 },
                            { x: wristX + size, y: wristY - size * 0.3 },
                            { x: wristX + 10, y: wristY + size * 0.7 },
                            { x: wristX + size, y: wristY + size * 0.7 }
                        ],
                        gridWidth: 2,
                        gridHeight: 2,
                        visible: true
                    };
                }
                return null;
            }

            // Hats and head accessories
            if (['hat', 'cap', 'beanie', 'helmet', 'headband'].includes(category)) {
                if (!nose || !leftEye || !rightEye) return null;
                if (!checkVisibility(0.3, nose, leftEye, rightEye)) {
                    return { visible: false };
                }

                const headWidth = Math.abs(rightEye.x - leftEye.x) * width * 2;
                const headCenterX = (leftEye.x + rightEye.x) / 2 * width;
                const headTopY = Math.min(leftEye.y, rightEye.y) * height - 60;

                return {
                    points: [
                        { x: headCenterX - headWidth * 0.6, y: headTopY },
                        { x: headCenterX + headWidth * 0.6, y: headTopY },
                        { x: headCenterX - headWidth * 0.6, y: headTopY + headWidth * 0.8 },
                        { x: headCenterX + headWidth * 0.6, y: headTopY + headWidth * 0.8 }
                    ],
                    gridWidth: 2,
                    gridHeight: 2,
                    visible: true
                };
            }

            // Default - simple quad
            return {
                points: [
                    { x: leftShoulder.x * width, y: leftShoulder.y * height },
                    { x: rightShoulder.x * width, y: rightShoulder.y * height },
                    { x: leftShoulder.x * width, y: leftShoulder.y * height + 100 },
                    { x: rightShoulder.x * width, y: rightShoulder.y * height + 100 }
                ],
                gridWidth: 2,
                gridHeight: 2,
                visible: true
            };
        }

        // Draw clothing overlaid on body segments
        function drawSegmentedClothing(ctx, image, segments, scale, offsetY, widthMult) {
            if (!segments || segments.length === 0) {
                console.error('‚ùå No segments to draw');
                return;
            }

            console.log(`üìê Drawing ${segments.length} segments`);

            ctx.save();
            ctx.globalAlpha = 0.85;

            segments.forEach((segment, idx) => {
                if (!segment.visible) {
                    console.log(`  Segment ${idx} not visible`);
                    return;
                }

                if (!segment.boundary) {
                    console.error(`  ‚ùå Segment ${idx} (${segment.name}) has no boundary`);
                    return;
                }

                console.log(`  ‚úì Drawing segment ${idx} (${segment.name}), boundary points: ${segment.boundary.length}`);

                // Get the UV region for this segment (which part of the image to use)
                const uv = segment.uvRegion || { u0: 0, v0: 0, u1: 1, v1: 1 };

                // Calculate the bounding box of the segment
                const xs = segment.boundary.map(p => p.x);
                const ys = segment.boundary.map(p => p.y + offsetY);
                const minX = Math.min(...xs);
                const maxX = Math.max(...xs);
                const minY = Math.min(...ys);
                const maxY = Math.max(...ys);

                // Apply user scale
                const segmentWidth = (maxX - minX) * widthMult;
                const segmentHeight = (maxY - minY) * scale;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                console.log(`    Size: ${segmentWidth.toFixed(0)}x${segmentHeight.toFixed(0)} at (${centerX.toFixed(0)}, ${centerY.toFixed(0)})`);

                // Adjust boundary points for scale
                const scaledBoundary = segment.boundary.map(p => ({
                    x: centerX + (p.x - (minX + maxX) / 2) * widthMult,
                    y: centerY + (p.y - (minY + maxY) / 2) * scale + offsetY
                }));

                // Create clipping region for this segment
                ctx.save();
                ctx.beginPath();
                scaledBoundary.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.closePath();
                ctx.clip();

                // Draw the portion of the image for this segment
                const sourceX = uv.u0 * image.width;
                const sourceY = uv.v0 * image.height;
                const sourceWidth = (uv.u1 - uv.u0) * image.width;
                const sourceHeight = (uv.v1 - uv.v0) * image.height;

                const destX = centerX - segmentWidth / 2;
                const destY = centerY - segmentHeight / 2;

                try {
                    ctx.drawImage(
                        image,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        destX, destY, segmentWidth, segmentHeight
                    );
                    console.log(`    ‚úÖ Drew image portion UV(${uv.u0.toFixed(2)},${uv.v0.toFixed(2)}) to (${uv.u1.toFixed(2)},${uv.v1.toFixed(2)})`);
                } catch (error) {
                    console.error(`    ‚ùå Failed to draw image:`, error);
                }

                ctx.restore();
            });

            ctx.globalAlpha = 1.0;
            ctx.restore();
        }

        // Old mesh warping system (keeping for reference, but not used)
        function drawWarpedClothing(ctx, image, anchorPoints, scale, offsetY, widthMult) {
            if (!anchorPoints || !anchorPoints.points || anchorPoints.points.length < 4) return;

            const points = anchorPoints.points.map(p => ({
                x: p.x,
                y: p.y + offsetY
            }));

            const gridWidth = anchorPoints.gridWidth;
            const gridHeight = anchorPoints.gridHeight;

            ctx.save();
            ctx.globalAlpha = 0.85;

            // Draw mesh using triangles for better warping
            for (let row = 0; row < gridHeight - 1; row++) {
                for (let col = 0; col < gridWidth - 1; col++) {
                    const idx = row * gridWidth + col;
                    const p0 = points[idx];
                    const p1 = points[idx + 1];
                    const p2 = points[idx + gridWidth];
                    const p3 = points[idx + gridWidth + 1];

                    // Calculate UV coordinates (texture mapping)
                    const u0 = col / (gridWidth - 1);
                    const v0 = row / (gridHeight - 1);
                    const u1 = (col + 1) / (gridWidth - 1);
                    const v1 = (row + 1) / (gridHeight - 1);

                    // Draw two triangles for this quad
                    drawTexturedTriangle(ctx, image,
                        p0.x, p0.y, p1.x, p1.y, p2.x, p2.y,
                        u0, v0, u1, v0, u0, v1,
                        scale, widthMult
                    );
                    drawTexturedTriangle(ctx, image,
                        p1.x, p1.y, p3.x, p3.y, p2.x, p2.y,
                        u1, v0, u1, v1, u0, v1,
                        scale, widthMult
                    );
                }
            }

            ctx.globalAlpha = 1.0;
            ctx.restore();
        }

        // Draw a textured triangle using affine texture mapping
        function drawTexturedTriangle(ctx, image, x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, scale, widthMult) {
            // Apply scale adjustments to UV coordinates
            const imgWidth = image.width;
            const imgHeight = image.height;

            const sx0 = u0 * imgWidth;
            const sy0 = v0 * imgHeight;
            const sx1 = u1 * imgWidth;
            const sy1 = v1 * imgHeight;
            const sx2 = u2 * imgWidth;
            const sy2 = v2 * imgHeight;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.closePath();
            ctx.clip();

            // Calculate transformation matrix for affine mapping
            const denom = (sx1 - sx0) * (sy2 - sy0) - (sx2 - sx0) * (sy1 - sy0);
            if (Math.abs(denom) < 0.0001) {
                ctx.restore();
                return;
            }

            const m11 = ((x1 - x0) * (sy2 - sy0) - (x2 - x0) * (sy1 - sy0)) / denom;
            const m12 = ((x2 - x0) * (sx1 - sx0) - (x1 - x0) * (sx2 - sx0)) / denom;
            const m21 = ((y1 - y0) * (sy2 - sy0) - (y2 - y0) * (sy1 - sy0)) / denom;
            const m22 = ((y2 - y0) * (sx1 - sx0) - (y1 - y0) * (sx2 - sx0)) / denom;
            const dx = x0 - (m11 * sx0 + m12 * sy0);
            const dy = y0 - (m21 * sx0 + m22 * sy0);

            ctx.transform(m11, m21, m12, m22, dx, dy);
            ctx.drawImage(image, 0, 0);
            ctx.restore();
        }

        // Advanced proportional sizing based on body measurements
        function calculateProportionalSizing(landmarks, category, width, height, mesh) {
            const categoryLower = category.toLowerCase();

            // Get key body measurements
            const bodyMeasurements = getBodyMeasurements(landmarks, width, height);
            if (!bodyMeasurements) return null;

            const imageAspectRatio = mesh.height / mesh.width;

            // Category-specific sizing logic
            if (['shirt', 'top', 'blouse', 'jacket', 'coat', 'sweater', 'hoodie'].includes(categoryLower)) {
                // Upper body: base on shoulder width and torso length
                const shoulderWidth = bodyMeasurements.shoulderWidth;
                const torsoLength = bodyMeasurements.torsoLength;

                return {
                    width: shoulderWidth * 1.4, // Clothing typically 40% wider than shoulders
                    height: Math.max(torsoLength * 0.8, shoulderWidth * 1.4 * imageAspectRatio),
                    bodyMeasurement: shoulderWidth,
                    yOffset: torsoLength * 0.1 // Slight downward offset
                };
            }

            if (['pants', 'jeans', 'trousers', 'shorts', 'leggings'].includes(categoryLower)) {
                // Lower body: base on hip width and leg length
                const hipWidth = bodyMeasurements.hipWidth;
                const legLength = bodyMeasurements.legLength;

                let heightMultiplier = 0.85; // Full pants
                if (['shorts'].includes(categoryLower)) {
                    heightMultiplier = 0.35; // Shorts are much shorter
                }

                return {
                    width: hipWidth * 1.2, // Pants slightly wider than hips
                    height: legLength * heightMultiplier,
                    bodyMeasurement: hipWidth,
                    yOffset: legLength * 0.05 // Slight offset for natural hang
                };
            }

            if (['dress', 'skirt', 'jumpsuit', 'romper'].includes(categoryLower)) {
                // Full body: shoulder width but full body length
                const shoulderWidth = bodyMeasurements.shoulderWidth;
                const fullBodyLength = bodyMeasurements.fullBodyLength;

                let heightMultiplier = 0.75; // Full dress
                if (['skirt'].includes(categoryLower)) {
                    heightMultiplier = 0.45; // Skirts are shorter
                }

                return {
                    width: shoulderWidth * 1.5,
                    height: fullBodyLength * heightMultiplier,
                    bodyMeasurement: shoulderWidth,
                    yOffset: fullBodyLength * 0.05
                };
            }

            if (['shoes', 'boots', 'sneakers', 'sandals', 'heels'].includes(categoryLower)) {
                // Footwear: base on foot width estimate
                const footWidth = bodyMeasurements.shoulderWidth * 0.25; // Approximate foot width

                return {
                    width: footWidth * 1.8,
                    height: footWidth * 1.8 * imageAspectRatio,
                    bodyMeasurement: footWidth,
                    yOffset: 10 // Slight offset below ankles
                };
            }

            if (['bag', 'purse', 'handbag', 'backpack', 'accessory', 'jewelry', 'watch', 'bracelet'].includes(categoryLower)) {
                // Accessories: much smaller, based on hand/arm proportions
                const handSize = bodyMeasurements.armLength * 0.15; // Approximate hand size

                let sizeMultiplier = 1.5; // Default for bags
                if (['jewelry', 'watch', 'bracelet'].includes(categoryLower)) {
                    sizeMultiplier = 0.8; // Smaller for jewelry
                } else if (['backpack'].includes(categoryLower)) {
                    sizeMultiplier = 2.5; // Larger for backpacks
                }

                return {
                    width: handSize * sizeMultiplier,
                    height: handSize * sizeMultiplier * imageAspectRatio,
                    bodyMeasurement: handSize,
                    yOffset: 0
                };
            }

            if (['hat', 'cap', 'beanie', 'helmet', 'headband'].includes(categoryLower)) {
                // Headwear: base on head width estimate
                const headWidth = bodyMeasurements.shoulderWidth * 0.4; // Approximate head width

                return {
                    width: headWidth * 1.2,
                    height: headWidth * 1.2 * imageAspectRatio,
                    bodyMeasurement: headWidth,
                    yOffset: -20 // Above the head
                };
            }

            // Default fallback - treat as upper body
            const shoulderWidth = bodyMeasurements.shoulderWidth;
            return {
                width: shoulderWidth * 1.3,
                height: shoulderWidth * 1.3 * imageAspectRatio,
                bodyMeasurement: shoulderWidth,
                yOffset: 0
            };
        }

        // Extract key body measurements from pose landmarks
        function getBodyMeasurements(landmarks, width, height) {
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const leftElbow = landmarks[13];
            const rightElbow = landmarks[14];
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];

            // Additional key points for better mapping
            const nose = landmarks[0];
            const leftEye = landmarks[2];
            const rightEye = landmarks[5];
            const leftEar = landmarks[7];
            const rightEar = landmarks[8];

            if (!leftShoulder || !rightShoulder) return null;

            // Calculate key measurements in pixels with improved accuracy
            const shoulderWidth = Math.sqrt(
                Math.pow((rightShoulder.x - leftShoulder.x) * width, 2) +
                Math.pow((rightShoulder.y - leftShoulder.y) * height, 2)
            );

            // Calculate shoulder angle for rotation detection
            const shoulderAngle = Math.atan2(
                (rightShoulder.y - leftShoulder.y) * height,
                (rightShoulder.x - leftShoulder.x) * width
            );

            // Calculate hip width with improved measurement
            let hipWidth = shoulderWidth * 0.9; // Default estimate
            if (leftHip && rightHip) {
                hipWidth = Math.sqrt(
                    Math.pow((rightHip.x - leftHip.x) * width, 2) +
                    Math.pow((rightHip.y - leftHip.y) * height, 2)
                );
            }

            // Calculate chest/torso center point (midway between shoulders and hips)
            let chestCenter = null;
            let waistCenter = null;
            if (leftHip && rightHip) {
                chestCenter = {
                    x: (leftShoulder.x + rightShoulder.x) / 2,
                    y: (leftShoulder.y + rightShoulder.y) / 2 + ((leftHip.y + rightHip.y) / 2 - (leftShoulder.y + rightShoulder.y) / 2) * 0.3
                };
                waistCenter = {
                    x: (leftShoulder.x + rightShoulder.x) / 2,
                    y: (leftShoulder.y + rightShoulder.y) / 2 + ((leftHip.y + rightHip.y) / 2 - (leftShoulder.y + rightShoulder.y) / 2) * 0.7
                };
            }

            // Improved torso length calculation
            let torsoLength = shoulderWidth * 0.8; // Default estimate
            if (leftHip && rightHip) {
                const shoulderY = (leftShoulder.y + rightShoulder.y) / 2 * height;
                const hipY = (leftHip.y + rightHip.y) / 2 * height;
                torsoLength = Math.abs(hipY - shoulderY);
            }

            // Calculate upper torso (shoulder to chest) and lower torso (chest to hips) separately
            const upperTorsoLength = torsoLength * 0.4;
            const lowerTorsoLength = torsoLength * 0.6;

            // Improved leg length with knee consideration
            let legLength = shoulderWidth * 1.2; // Default estimate
            let thighLength = legLength * 0.5;
            let calfLength = legLength * 0.5;

            if (leftHip && rightHip && leftKnee && rightKnee && leftAnkle && rightAnkle) {
                const hipY = (leftHip.y + rightHip.y) / 2 * height;
                const kneeY = (leftKnee.y + rightKnee.y) / 2 * height;
                const ankleY = (leftAnkle.y + rightAnkle.y) / 2 * height;

                legLength = Math.abs(ankleY - hipY);
                thighLength = Math.abs(kneeY - hipY);
                calfLength = Math.abs(ankleY - kneeY);
            }

            // Improved arm length with full arm measurement
            let armLength = shoulderWidth * 0.9; // Default estimate
            let upperArmLength = armLength * 0.45;
            let forearmLength = armLength * 0.45;

            if (leftElbow && rightElbow && leftWrist && rightWrist) {
                // Calculate right arm (usually dominant)
                const shoulderToElbow = Math.sqrt(
                    Math.pow((rightElbow.x - rightShoulder.x) * width, 2) +
                    Math.pow((rightElbow.y - rightShoulder.y) * height, 2)
                );
                const elbowToWrist = Math.sqrt(
                    Math.pow((rightWrist.x - rightElbow.x) * width, 2) +
                    Math.pow((rightWrist.y - rightElbow.y) * height, 2)
                );

                upperArmLength = shoulderToElbow;
                forearmLength = elbowToWrist;
                armLength = upperArmLength + forearmLength;
            }

            // Calculate neck position and length
            let neckLength = shoulderWidth * 0.15;
            let neckCenter = null;
            if (nose && leftEar && rightEar) {
                const earCenterY = (leftEar.y + rightEar.y) / 2;
                const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2;
                neckLength = Math.abs(shoulderCenterY - earCenterY) * height;
                neckCenter = {
                    x: (leftShoulder.x + rightShoulder.x) / 2,
                    y: shoulderCenterY - neckLength / height / 2
                };
            }

            // Calculate body rotation (how much the person is turned)
            let bodyRotation = 0;
            if (leftShoulder && rightShoulder && leftHip && rightHip) {
                const shoulderDist = Math.abs(rightShoulder.x - leftShoulder.x);
                const hipDist = Math.abs(rightHip.x - leftHip.x);
                bodyRotation = Math.atan2(shoulderDist - hipDist, torsoLength / height);
            }

            const fullBodyLength = torsoLength + legLength;

            return {
                // Basic measurements
                shoulderWidth,
                hipWidth,
                torsoLength,
                legLength,
                armLength,
                fullBodyLength,
                neckLength,

                // Detailed measurements
                upperTorsoLength,
                lowerTorsoLength,
                thighLength,
                calfLength,
                upperArmLength,
                forearmLength,

                // Angle and rotation info
                shoulderAngle,
                bodyRotation,

                // Key body points for precise positioning
                chestCenter,
                waistCenter,
                neckCenter
            };
        }

        function getClothingPositionByCategory(landmarks, category, width, height) {
            console.log('üéØ Positioning item:', category, 'Total landmarks:', landmarks.length);

            // MediaPipe Pose landmarks indices
            const leftShoulder = landmarks[11];
            const rightShoulder = landmarks[12];
            const leftElbow = landmarks[13];
            const rightElbow = landmarks[14];
            const leftWrist = landmarks[15];
            const rightWrist = landmarks[16];
            const leftHip = landmarks[23];
            const rightHip = landmarks[24];
            const leftKnee = landmarks[25];
            const rightKnee = landmarks[26];
            const leftAnkle = landmarks[27];
            const rightAnkle = landmarks[28];
            const nose = landmarks[0];
            const leftEye = landmarks[2];
            const rightEye = landmarks[5];

            // Always require shoulders as basic reference
            if (!leftShoulder || !rightShoulder) {
                console.warn('‚ùå Missing shoulder landmarks for:', category);
                return null;
            }

            // Get body measurements for better positioning
            const bodyMeasurements = getBodyMeasurements(landmarks, width, height);

            const categoryLower = category.toLowerCase();
            console.log('üîç Category match for:', categoryLower);

            // Calculate shoulder center with depth consideration
            const shoulderCenterX = (leftShoulder.x + rightShoulder.x) / 2 * width;
            const shoulderCenterY = (leftShoulder.y + rightShoulder.y) / 2 * height;

            // Upper body clothing (shirts, jackets, etc.)
            if (['shirt', 'top', 'blouse', 'jacket', 'coat', 'sweater', 'hoodie'].includes(categoryLower)) {
                console.log('üëï Positioning as upper body item');

                // Use chest center if available for better positioning
                let posX = shoulderCenterX;
                let posY = shoulderCenterY;

                if (bodyMeasurements && bodyMeasurements.chestCenter) {
                    posX = bodyMeasurements.chestCenter.x * width;
                    posY = bodyMeasurements.chestCenter.y * height;
                } else {
                    posY += bodyMeasurements ? bodyMeasurements.upperTorsoLength * 0.5 : 20;
                }

                return {
                    x: posX,
                    y: posY,
                    baseWidth: bodyMeasurements ? bodyMeasurements.shoulderWidth * 1.35 : Math.abs(rightShoulder.x - leftShoulder.x) * width * 1.3,
                    rotation: bodyMeasurements ? bodyMeasurements.shoulderAngle : 0
                };
            }

            // Lower body clothing (pants, jeans, etc.)
            if (['pants', 'jeans', 'trousers', 'shorts', 'leggings'].includes(categoryLower)) {
                console.log('üëñ Positioning as lower body item');
                if (leftHip && rightHip) {
                    const hipCenterX = (leftHip.x + rightHip.x) / 2 * width;
                    const hipCenterY = (leftHip.y + rightHip.y) / 2 * height;

                    let posY = hipCenterY;

                    // Better positioning based on knees
                    if (leftKnee && rightKnee) {
                        const kneeY = (leftKnee.y + rightKnee.y) / 2 * height;
                        // Position at waist (slightly above hips) and extend to mid-thigh
                        posY = hipCenterY - (bodyMeasurements ? bodyMeasurements.lowerTorsoLength * 0.2 : 15);
                    }

                    return {
                        x: hipCenterX,
                        y: posY,
                        baseWidth: bodyMeasurements ? bodyMeasurements.hipWidth * 1.15 : Math.abs(rightHip.x - leftHip.x) * width * 1.1,
                        rotation: bodyMeasurements ? bodyMeasurements.shoulderAngle * 0.5 : 0
                    };
                }
                console.warn('‚ùå Missing hip landmarks for pants');
                return null;
            }

            // Full body clothing (dresses, jumpsuits)
            if (['dress', 'skirt', 'jumpsuit', 'romper'].includes(categoryLower)) {
                console.log('üëó Positioning as full body item');

                let posY = shoulderCenterY;

                // Use neck center for better dress positioning
                if (bodyMeasurements && bodyMeasurements.neckCenter) {
                    posY = bodyMeasurements.neckCenter.y * height + (bodyMeasurements.neckLength * 0.5);
                } else {
                    posY += 10;
                }

                return {
                    x: shoulderCenterX,
                    y: posY,
                    baseWidth: bodyMeasurements ? bodyMeasurements.shoulderWidth * 1.45 : Math.abs(rightShoulder.x - leftShoulder.x) * width * 1.4,
                    rotation: bodyMeasurements ? bodyMeasurements.shoulderAngle : 0
                };
            }

            // Footwear
            if (['shoes', 'boots', 'sneakers', 'sandals', 'heels'].includes(categoryLower)) {
                console.log('üëû Positioning as footwear');
                if (leftAnkle && rightAnkle) {
                    const ankleCenterX = (leftAnkle.x + rightAnkle.x) / 2 * width;
                    const ankleCenterY = (leftAnkle.y + rightAnkle.y) / 2 * height;

                    // Calculate ankle width with proper distance measurement
                    const ankleWidth = Math.sqrt(
                        Math.pow((rightAnkle.x - leftAnkle.x) * width, 2) +
                        Math.pow((rightAnkle.y - leftAnkle.y) * height, 2)
                    );

                    return {
                        x: ankleCenterX,
                        y: ankleCenterY + 25,
                        baseWidth: ankleWidth * 1.8,
                        rotation: 0
                    };
                }
                console.warn('‚ùå Missing ankle landmarks for shoes');
                return null;
            }

            // Accessories (bags, jewelry, etc.)
            if (['bag', 'purse', 'handbag', 'backpack', 'accessory', 'jewelry', 'watch', 'bracelet'].includes(categoryLower)) {
                console.log('üëú Positioning as accessory');

                if (['backpack'].includes(categoryLower)) {
                    // Backpacks go on the back/shoulders
                    return {
                        x: shoulderCenterX,
                        y: shoulderCenterY + 30,
                        baseWidth: bodyMeasurements ? bodyMeasurements.shoulderWidth * 0.7 : 80,
                        rotation: bodyMeasurements ? bodyMeasurements.shoulderAngle : 0
                    };
                }

                if (leftWrist && rightWrist) {
                    // Position near dominant hand (right hand) for handbags
                    const wristX = rightWrist.x * width;
                    const wristY = rightWrist.y * height;

                    return {
                        x: wristX + 30,
                        y: wristY,
                        baseWidth: 60,
                        rotation: 0
                    };
                } else if (leftElbow && rightElbow) {
                    // Fallback to elbow position
                    return {
                        x: rightElbow.x * width + 40,
                        y: rightElbow.y * height + 20,
                        baseWidth: 60,
                        rotation: 0
                    };
                }
                console.warn('‚ùå Missing wrist/elbow landmarks for accessory');
                return null;
            }

            // Hats and head accessories
            if (['hat', 'cap', 'beanie', 'helmet', 'headband'].includes(categoryLower)) {
                console.log('üé© Positioning as headwear');

                if (nose && leftEye && rightEye) {
                    // Use eye center for more accurate head positioning
                    const eyeCenterX = (leftEye.x + rightEye.x) / 2 * width;
                    const eyeCenterY = (leftEye.y + rightEye.y) / 2 * height;

                    return {
                        x: eyeCenterX,
                        y: eyeCenterY - (bodyMeasurements ? bodyMeasurements.neckLength * 1.2 : 80),
                        baseWidth: bodyMeasurements ? bodyMeasurements.shoulderWidth * 0.85 : Math.abs(rightShoulder.x - leftShoulder.x) * width * 0.8,
                        rotation: bodyMeasurements ? bodyMeasurements.shoulderAngle : 0
                    };
                } else if (nose) {
                    return {
                        x: nose.x * width,
                        y: nose.y * height - 80,
                        baseWidth: bodyMeasurements ? bodyMeasurements.shoulderWidth * 0.85 : Math.abs(rightShoulder.x - leftShoulder.x) * width * 0.8,
                        rotation: 0
                    };
                }
                console.warn('‚ùå Missing nose landmark for hat');
                return null;
            }

            // Default case - treat as upper body
            console.log('‚ö†Ô∏è Unknown category, defaulting to upper body positioning:', categoryLower);
            return {
                x: shoulderCenterX,
                y: shoulderCenterY + 20,
                baseWidth: bodyMeasurements ? bodyMeasurements.shoulderWidth * 1.3 : Math.abs(rightShoulder.x - leftShoulder.x) * width * 1.3,
                rotation: bodyMeasurements ? bodyMeasurements.shoulderAngle : 0
            };
        }

        function drawARPoseSkeleton(ctx, landmarks, width, height) {
            ctx.fillStyle = '#00ff00';
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;

            // Draw more comprehensive landmarks for debugging
            const keyPoints = [
                { indices: [11, 12], color: '#ff0000', label: 'Shoulders' },
                { indices: [13, 14], color: '#ff8800', label: 'Elbows' },
                { indices: [15, 16], color: '#ffff00', label: 'Wrists' },
                { indices: [23, 24], color: '#00ff00', label: 'Hips' },
                { indices: [25, 26], color: '#0088ff', label: 'Knees' },
                { indices: [27, 28], color: '#8800ff', label: 'Ankles' },
                { indices: [0], color: '#ff00ff', label: 'Nose' }
            ];

            // Draw points with different colors
            keyPoints.forEach(({ indices, color, label }) => {
                ctx.fillStyle = color;
                indices.forEach(index => {
                    if (landmarks[index]) {
                        const x = landmarks[index].x * width;
                        const y = landmarks[index].y * height;
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, 2 * Math.PI);
                        ctx.fill();

                        // Add labels
                        ctx.fillStyle = '#ffffff';
                        ctx.font = '12px Arial';
                        ctx.fillText(`${label}${indices.length > 1 ? (index === indices[0] ? '-L' : '-R') : ''}`, x + 10, y - 10);
                        ctx.fillStyle = color;
                    }
                });
            });

            // Draw connections
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            const connections = [
                [11, 12], // shoulders
                [11, 13], [13, 15], // left arm
                [12, 14], [14, 16], // right arm
                [11, 23], [12, 24], // shoulder to hip
                [23, 24], // hips
                [23, 25], [25, 27], // left leg
                [24, 26], [26, 28]  // right leg
            ];

            connections.forEach(([from, to]) => {
                if (landmarks[from] && landmarks[to]) {
                    ctx.beginPath();
                    ctx.moveTo(landmarks[from].x * width, landmarks[from].y * height);
                    ctx.lineTo(landmarks[to].x * width, landmarks[to].y * height);
                    ctx.stroke();
                }
            });
        }

        function updateAROutfitDisplay() {
            const container = document.getElementById('arCurrentOutfitDisplay');
            const outfitItems = Object.values(selectedOutfit).filter(Boolean);
            if (outfitItems.length === 0) {
                container.innerHTML = '<p class="text-sm text-white/60">No outfit selected</p>';
                return;
            }
            container.innerHTML = `
                <div class="text-sm text-white font-medium mb-2">AR Outfit (${outfitItems.length} items):</div>
                ${outfitItems.map(item => `<div class="text-xs text-white/80 mb-1">‚Ä¢ ${item.category}</div>`).join('')}
            `;
        }

        function updateARClothingTransform() {
            const scale = parseFloat(document.getElementById('arScaleSlider').value);
            const offsetY = parseInt(document.getElementById('arOffsetSlider').value);
            const width = parseFloat(document.getElementById('arWidthSlider').value);
            arClothingTransform = { scale, offsetY, width };
            document.getElementById('arScaleValue').textContent = scale.toFixed(1);
            document.getElementById('arOffsetValue').textContent = offsetY;
            document.getElementById('arWidthValue').textContent = width.toFixed(1);
        }

        function toggleARClothing() {
            arClothingVisible = !arClothingVisible;
            document.getElementById('arToggleBtn').style.backgroundColor = arClothingVisible ? '#7c3aed' : '#6b7280';
        }

        function resetARTransform() {
            arClothingTransform = { scale: 1, offsetY: 0, width: 1.6 };
            document.getElementById('arScaleSlider').value = 1;
            document.getElementById('arOffsetSlider').value = 0;
            document.getElementById('arWidthSlider').value = 1.6;
            updateARClothingTransform();
        }

        function toggleARDebugMode() {
            arDebugMode = !arDebugMode;
            document.getElementById('arDebugInfo').style.display = arDebugMode ? 'block' : 'none';
            document.getElementById('arDebugBtn').style.backgroundColor = arDebugMode ? '#dc2626' : '#4b5563';
        }

        function exitAR() {
            console.log('‚ùå Exiting AR mode...');
            arDetectionActive = false;
            if (arCameraStream) {
                arCameraStream.getTracks().forEach(track => track.stop());
                arCameraStream = null;
            }
            document.getElementById('arFullscreen').classList.add('hidden');
            document.getElementById('arControlsPanel').style.display = 'none';
            document.getElementById('arDebugInfo').style.display = 'none';
            const canvas = document.getElementById('arOverlayCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            console.log('‚úÖ AR mode exited');
        }

        setInterval(() => {
            const currentTime = performance.now();
            const fps = Math.round(arFrameCount * 1000 / (currentTime - arLastTime));
            const fpsCounter = document.getElementById('arFpsCounter');
            if (fpsCounter) fpsCounter.textContent = fps;
            arFrameCount = 0;
            arLastTime = currentTime;
        }, 1000);

        function checkARSupport() {
            const cameraSupported = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            document.getElementById('cameraSupport').innerHTML = `üìπ Camera: <span class="${cameraSupported ? 'text-green-400' : 'text-red-400'}">${cameraSupported ? 'Supported' : 'Not Supported'}</span>`;
            const httpsSupported = location.protocol === 'https:' || location.hostname === 'localhost';
            document.getElementById('httpsSupport').innerHTML = `üîí HTTPS: <span class="${httpsSupported ? 'text-green-400' : 'text-red-400'}">${httpsSupported ? 'Supported' : 'Required'}</span>`;
            const canvas = document.createElement('canvas');
            const webglSupported = !!(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
            document.getElementById('webglSupport').innerHTML = `üéÆ WebGL: <span class="${webglSupported ? 'text-green-400' : 'text-red-400'}">${webglSupported ? 'Supported' : 'Not Supported'}</span>`;
        }

        function updateCurrentOutfitDisplay() {
            const container = document.getElementById('currentOutfitDisplay');
            const outfitItems = Object.values(selectedOutfit).filter(Boolean);
            if (outfitItems.length === 0) {
                container.innerHTML = '<p class="text-white/60 text-center">No outfit selected</p><p class="text-white/40 text-sm text-center mt-2">Go to "Pick Outfit" to select items</p>';
                return;
            }
            container.innerHTML = outfitItems.map(item => `
                <div class="flex items-center gap-3 bg-white/10 rounded-lg p-3">
                    <img src="${item.image}" alt="${item.category}" class="w-12 h-12 object-cover rounded">
                    <div class="flex-1">
                        <div class="text-sm font-medium text-white">${item.category}</div>
                        <div class="text-xs text-white/60">${Math.round(item.confidence * 100)}% confidence</div>
                    </div>
                </div>
            `).join('');
        }

        // Initialize AR support check when page loads
        document.addEventListener('DOMContentLoaded', function() {
            checkARSupport();
        });

        // Initialize the app
        showTab('closet');
    </script>
</body>
</html>